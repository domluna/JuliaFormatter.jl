var documenterSearchIndex = {"docs":
[{"location":"sciml_style/#SciML-Style","page":"SciML Style","title":"SciML Style","text":"","category":"section"},{"location":"sciml_style/#Configuration-File-Example","page":"SciML Style","title":"Configuration File Example","text":"The .JuliaFormatter.toml which represents these settings is\n\nstyle = \"sciml\"\n\nOr to use SciMLStyle except change one of the settings:\n\nstyle = \"sciml\"\nremove_extra_newlines = false","category":"section"},{"location":"sciml_style/#Direct-Usage","page":"SciML Style","title":"Direct Usage","text":"format(\"file.jl\", SciMLStyle())\n\nOr to use SciMLStyle except change one of the settings:\n\nformat(\"file.jl\", SciMLStyle(), remove_extra_newlines=false)","category":"section"},{"location":"sciml_style/#Additional-Options","page":"SciML Style","title":"Additional Options","text":"The SciMLStyle supports the additional options variable_call_indent and yas_style_nesting.\n\nThe option variable_call_indent is set to [] by default. It allows calls without aligning to the opening parenthesis:\n\n# Allowed with and without `Dict in variable_call_indent`\nDict{Int, Int}(1 => 2,\n    3 => 4)\n\n# Allowed when `Dict in variable_call_indent`, but\n# will be changed to the first example when `Dict ∉ variable_call_indent`.\nDict{Int, Int}(\n    1 => 2,\n    3 => 4)\n\nThe option yas_style_nesting is set to false by default. Setting it to true makes the SciMLStyle use the YASStyle nesting rules:\n\n# With `yas_style_nesting = false`\nfunction my_large_function(argument1, argument2,\n        argument3, argument4,\n        argument5, x, y, z)\n    foo(x) + goo(y)\nend\n\n# With `yas_style_nesting = true`\nfunction my_large_function(argument1, argument2,\n                           argument3, argument4,\n                           argument5, x, y, z)\n    foo(x) + goo(y)\nend","category":"section"},{"location":"sciml_style/#JuliaFormatter.SciMLStyle","page":"SciML Style","title":"JuliaFormatter.SciMLStyle","text":"SciMLStyle()\n\nFormatting style based on SciMLStyle.\n\nConfigurable options with different defaults to DefaultStyle are:\n\nalways_for_in = true\ndisallow_single_arg_nesting = true\njoin_lines_based_on_source = true\nnormalize_line_endings = unix\nremove_extra_newlines = true\nshort_to_long_function_def = true\ntrailing_comma = false\nwhitespace_ops_in_indices = true\nwhitespace_typedefs = true\nyas_style_nesting = false\n\n\n\n\n\n","category":"type"},{"location":"config/#config","page":"Configuration File","title":"Configuration File","text":"From v0.4.3, JuliaFormatter offers .prettierrc style configuration file support. This means you can specify formatting options shown in format_text in .JuliaFormatter.toml file and share that with others.\n\nWhen format is called, it will look for .JuliaFormatter.toml in the location of the file being formatted, and searching up the file tree until a config file is (or isn't) found. When found, the configurations in the file will overwrite the given options.","category":"section"},{"location":"config/#Basic-Configuration","page":"Configuration File","title":"Basic Configuration","text":"In .JuliaFormatter.toml, you can specify any of the formatting options shown in format_text in TOML, e.g. if you have\n\nsomedir/.JuliaFormatter.toml\n\nindent = 2\nmargin = 100\n\nthen files under somedir will be formatted with 2 spaces indentation and the maximum line length 100.","category":"section"},{"location":"config/#Non-Default-Style","page":"Configuration File","title":"Non Default Style","text":"If you would use another style, such as YASStyle you can write this in your configuration like so:\n\nstyle = \"yas\"\n\nStyles choices are:\n\n\"default\" (default choice if nothing is specified)\n\"yas\"\n\"blue\"\n\"sciml\"\n\"minimal\"","category":"section"},{"location":"config/#Search-Rule","page":"Configuration File","title":"Search Rule","text":".JuliaFormatter.toml will be searched up from the directory of the file being formatted. So if you have:\n\ndir\n├─ .JuliaFormatter.toml\n├─ code.jl\n└─ subdir\n   └─ sub_code.jl\n\nthen format(\"subdir/sub_code.jl\") will be automatically configured by the dir/.JuliaFormatter.toml, as well as format(\"dir\") will format both dir/code.jl and dir/subdir/sub_code.jl according to the same configuration.\n\nWhat will happen when we have multiple .JuliaFormatter.toml files ? In that case, the deepest configuration has the precedence. For example, if you have\n\ndir\n├─ .JuliaFormatter.toml\n├─ code.jl\n├─ subdir1\n│  ├─ .JuliaFormatter.toml\n│  └─ sub_code1.jl\n└─ subdir2\n   └─ sub_code2.jl\n\nand call format(\"dir\"), code.jl and sub_code2.jl will be formatted according to the rules defined in dir/.JuliaFormatter.toml, while formatting sub_code1.jl will be configured by dir/subdir1/.JuliaFormatter.toml.","category":"section"},{"location":"config/#ignore","page":"Configuration File","title":"Ignoring specific files and directories","text":"If there is an entry in .JuliaFormatter.toml with\n\nignore = [\"file.jl\", \"directory\", \"file_*.jl\"]\n\nthen all of these files will be reported as already formatted: ./file.jl, ./directory/something.jl ./other_directory/file.jl, file_1.jl, .other_directory/file_name.jl.","category":"section"},{"location":"style/#Style","page":"Code Style","title":"Style","text":"This is meant to give an impression of how the output of a formatted file looks like. Additional examples can be found in the test files.","category":"section"},{"location":"style/#Initial-FST","page":"Code Style","title":"Initial FST","text":"All examples assume indentation of 4 spaces\n\nFunctions, macros, structs with no arguments are placed on a single line:\n\nfunction  foo\nend\n\n->\n\nfunction foo end\n\nThis also applies to abstract and primitive types:\n\nabstract type\nAbstractFoo\nend\n\n->\n\nabstract type AbstractFoo end\n\nFunctions calls foo(args...), tuples (args...), arrays [args...], braces {args...}, struct or where definitions Foo{args...} are placed on a single line. This applies to any code which has opening and closing punctuation: (...), {...}, [...].\n\nf(\n\na,b\n\n,c )\n\n->\n\nf(a, b, c)\n\nBy default type definitions have no whitespace after commas:\n\nFoo{\na,b\n,c }\n\n->\n\nFoo{a,b,c}\n\nBlocks and their bodies are spread across multiple lines properly indented.\n\nExample 1:\n\nbegin\n  a\n    b; c\n       end\n\n->\n\nbegin\n    a\n    b\n    c\nend\n\nExample 2:\n\nstruct Foo{A, B}\n a::A\n  b::B\nend\n\n->\n\nstruct Foo{A,B}\n    a::A\n    b::B\nend\n\nBinary calls are placed on a single line and separated by whitespace. The exception to this are colon operations and operations inside an indexing expression. The latter being optional.\n\nExample 1:\n\na+b\n\n-> \n\na + b\n\nExample 2:\n\na : a : c\n\n->\n\na:b:c\n\nExample 3:\n\nlist[a + b]\n\n->\n\nlist[a+b]\n\nConditionals are placed on a single line and separated by whitespace.\n\ncond1 ?\nexpr1 :     expr2\n\n->\n\ncond1 ? expr1 : expr2\n\nComments are aligned to surrounding code blocks.\n\n# comment\nif a\n# comment\nelseif b\n# comment\nelseif c\n# comment\nelse\n# comment\nend\n# comment\n\n->\n\n# comment\nif a\n    # comment\nelseif b\n    # comment\nelseif c\n    # comment\nelse\n    # comment\nend\n# comment","category":"section"},{"location":"style/#Nesting-FST","page":"Code Style","title":"Nesting FST","text":"Binary operations and conditionals are nested back-to-front.\n\nExample 1:\n\narg1 + arg2\n\n->\n\narg1 + \narg2\n\nExample 2:\n\ncond ? e1 : e2\n\n->\n\ncond ? e1 :\ne2\n\n->\n\ncond ? \ne1 :\ne2\n\nIf nesting is required for a = binary operation, the RHS is placed on the following line and indented.\n\nfoo() = body\n\n->\n\nfoo() =\n    body\n\nLazy && and || operations are nested according to is_standalone_shortcircuit rules.\n\nAll arguments of a function call (applies to any opening/closing punctuation type) are nested if the expression exceeds the margin. The arguments are indented one level.\n\nfunction longfunctionname_that_is_long(lots, of, args, even, more, args)\n    body\nend\n\n->\n\nfunction longfunctionname_that_is_long(\n    lots, \n    of, \n    args,\n    even, \n    more, \n    args,\n)\n    body\nend\n\nWith where operations (A where B), A is nested prior to B.\n\nfunction f(arg1::A, key1 = val1; key2 = val2) where {A,B,C}\n    body\nend\n\n->\n\nfunction f(\n    arg1::A,\n    key1 = val1;\n    key2 = val2,\n) where {A,B,C}\n    body\nend\n\n-> \n\nfunction f(\n    arg1::A,\n    key1 = val1;\n    key2 = val2,\n) where {\n    A,\n    B,\n    C,\n}\n    body\nend\n\nIf a comment is detected inside of an expression, that expression is automatically nested:\n\nvar = foo(\n    a, b, # comment\n    c,\n)\n\n->\n\nvar = foo(\n    a,\n    b, # comment\n    c,\n)","category":"section"},{"location":"style/#Unnesting-FST","page":"Code Style","title":"Unnesting FST","text":"In certain cases it's desirable to unnest parts of a FST.\n\nExample 1:\n\n# short function def\nfunction foo(arg1, arg2, arg3) = body\n\n-> \n\nfunction foo(arg1, arg2, arg3) =\n    body\n\n->\n\nfunction foo(\n    arg1,\n    arg2,\n    arg3,\n) =\n    body\n\n# If the margin allows it, `body` will be joined back\n# with the previous line.\n\nfunction foo(\n    arg1,\n    arg2,\n    arg3,\n) = body\n\nExample 2:\n\nvar = funccall(arg1, arg2, arg3)\n\n-> \n\nvar =\n    funccall(arg1, arg2, arg3)\n\n->\n\nvar =\n    funccall(\n        arg1,\n        arg2,\n        arg3,\n    )\n\n# If the margin allows it, the RHS will be joined back\n# with the previous line.\n\nvar = funccall(\n    arg1,\n    arg2,\n    arg3,\n)","category":"section"},{"location":"yas_style/#YAS-Style","page":"YAS Style","title":"YAS Style","text":"","category":"section"},{"location":"yas_style/#Configuration-File-Example","page":"YAS Style","title":"Configuration File Example","text":"The .JuliaFormatter.toml which represents these settings is\n\nstyle = \"yas\"\n\nOr to use YASStyle except change one of the settings:\n\nstyle = \"yas\"\nremove_extra_newlines = false","category":"section"},{"location":"yas_style/#Direct-Usage","page":"YAS Style","title":"Direct Usage","text":"format(\"file.jl\", YASStyle())\n\nOr to use YASStyle except change one of the settings:\n\nformat(\"file.jl\", YASStyle(), remove_extra_newlines=false)","category":"section"},{"location":"yas_style/#Differences-from-DefaultStyle","page":"YAS Style","title":"Differences from DefaultStyle","text":"There are three main differences between YASStyle and DefaultStyle. They are based on alignment and line break behaviors.\n\nArguments are aligned to just after the start of the opener [, {, (, etc.\n\nfunction_call(arg1,\n              arg2)\n\nAs you can see from the above the closer sticks to the final argument.\nNesting (line breaks) only occur when the margin of the next argument exceeds the maximim limit.\n\nfunction_call(arg1, arg2,\n              arg3)\n\narg3 exceeded the margin limit and so it was placed on the following line.","category":"section"},{"location":"yas_style/#Nesting","page":"YAS Style","title":"Nesting =","text":"Unlike DefaultStyle, assignment operations = are not nested. That is, the following\n\nmy_function(arg1, arg2) = arg1 * arg2\n\nIs not nested to\n\nmy_function(arg1, arg2) =\n    arg1 * arg2\n\nIt is highly recommended setting short_to_long_function_def to true. This option transforms the above to a long function definition if it exceeds the maximum margin.\n\nfunction my_function(arg1, arg2)\n    arg1 * arg2\nend","category":"section"},{"location":"yas_style/#Additional-Options","page":"YAS Style","title":"Additional Options","text":"The YASStyle supports the additional option variable_call_indent, which is set to [] by default. It allows calls without aligning to the opening parenthesis:\n\n# Allowed with and without `Dict in variable_call_indent`\nDict{Int,Int}(1 => 2,\n              3 => 4)\n\n# Allowed when `Dict in variable_call_indent`, but\n# will be changed to the first example when `Dict ∉ variable_call_indent`.\nDict{Int,Int}(\n    1 => 2,\n    3 => 4)","category":"section"},{"location":"yas_style/#JuliaFormatter.YASStyle","page":"YAS Style","title":"JuliaFormatter.YASStyle","text":"YASStyle()\n\nFormatting style based on YASGuide and JuliaFormatter#198.\n\nConfigurable options with different defaults to DefaultStyle are:\n\nalways_for_in = true\nalways_use_return = true\nimport_to_using = true\njoin_lines_based_on_source = true\npipe_to_function_call = true\nremove_extra_newlines = true\nseparate_kwargs_with_semicolon = true\nshort_to_long_function_def = true\nwhitespace_in_kwargs = false\nwhitespace_ops_in_indices = true\nyas_style_nesting = false\n\n\n\n\n\n","category":"type"},{"location":"integrations/#Integrations","page":"Integrations","title":"Integrations","text":"","category":"section"},{"location":"integrations/#pre-commit","page":"Integrations","title":"pre-commit","text":"To learn more about pre-commit, check out their docs.\n\nWith Pull 674, support for  pre-commit was added. To add JuliaFormatter.jl to your own pre-commit workflow, add the following to your .pre-commit-config.yaml.\n\nrepos:\n# ... other repos you may have\n- repo: \"https://github.com/domluna/JuliaFormatter.jl\"\n  rev: \"v1.0.18\"  # or whatever the desired release is\n  hooks:\n  - id: \"julia-formatter\"\n# ... other repos you may have\n\nYou can find a list of releases here. Be sure to use the entire version string! (You can double-check this by opening the release and looking at the part of the URL that follows .../releases/tag/VERSION.)","category":"section"},{"location":"blue_style/#Blue-Style","page":"Blue Style","title":"Blue Style","text":"","category":"section"},{"location":"blue_style/#Configuration-File-Example","page":"Blue Style","title":"Configuration File Example","text":"The .JuliaFormatter.toml which represents these settings is\n\nstyle = \"blue\"\n\nOr to use BlueStyle except change one of the settings:\n\nstyle = \"blue\"\nremove_extra_newlines = false","category":"section"},{"location":"blue_style/#Direct-Usage","page":"Blue Style","title":"Direct Usage","text":"format(\"file.jl\", BlueStyle())\n\nOr to use BlueStyle except change one of the settings:\n\nformat(\"file.jl\", BlueStyle(), remove_extra_newlines=false)","category":"section"},{"location":"blue_style/#JuliaFormatter.BlueStyle","page":"Blue Style","title":"JuliaFormatter.BlueStyle","text":"BlueStyle()\n\nFormatting style based on BlueStyle and JuliaFormatter#283.\n\nnote: Note\nThis style is still work-in-progress, and does not yet implement all of the BlueStyle guide.\n\nConfigurable options with different defaults to DefaultStyle are:\n\nalways_for_in = true\nannotate_untyped_fields_with_any = false\nconditional_to_if = true\nimport_to_using = true\nindent_submodule = true\npipe_to_function_call = true\nremove_extra_newlines = true\nseparate_kwargs_with_semicolon = true\nshort_to_long_function_def = true\nwhitespace_in_kwargs = false\nwhitespace_ops_in_indices = true\nyas_style_nesting = false\n\n\n\n\n\n","category":"type"},{"location":"cli/#Command-Line-Interface","page":"Command Line Interface","title":"Command Line Interface","text":"JuliaFormatter provides a command-line executable jlfmt for formatting Julia source code.","category":"section"},{"location":"cli/#Installation","page":"Command Line Interface","title":"Installation","text":"Install using Julia's app manager:\n\npkg> app add JuliaFormatter\n\nThis makes the jlfmt command available in your PATH.\n\nAlternatively, invoke directly without installation:\n\njulia -m JuliaFormatter [<options>] <path>...\n\nnote: Runic Compatibility\nThe CLI interface is designed to be compatible with Runic.jl's CLI where possible, making it easier to switch between formatters.warning: Missing features\nNote that the --lines option is not yet implemented.","category":"section"},{"location":"cli/#Quick-Start","page":"Command Line Interface","title":"Quick Start","text":"# Preview formatted output\njlfmt src/file.jl\n\n# Check if files are already formatted with verbose mode\njlfmt --check -v src/\n\n# Format files in-place with multiple threads\njlfmt --threads=6 -- --inplace -v src/\n\n# Show diff without modifying\njlfmt --diff src/file.jl","category":"section"},{"location":"cli/#Options","page":"Command Line Interface","title":"Options","text":"Run jlfmt --help for a complete list:\n\nusing JuliaFormatter # hide\nJuliaFormatter.main([\"--help\"]); # hide","category":"section"},{"location":"cli/#Configuration-Files","page":"Command Line Interface","title":"Configuration Files","text":"jlfmt searches for .JuliaFormatter.toml configuration files starting from each input file's directory and walking up the directory tree.\n\nBy default, command-line options override configuration file settings:\n\n# Use indent=2 even if config file specifies indent=4\njlfmt --indent=2 src/file.jl\n\nUse --prioritize-config-file to make configuration file settings take precedence (might be useful for language server integration):\n\njlfmt --prioritize-config-file --indent=2 src/file.jl","category":"section"},{"location":"cli/#Configuration-with-stdin","page":"Command Line Interface","title":"Configuration with stdin","text":"When formatting from stdin, no configuration file is used by default. Use --config-dir to specify a directory for configuration file lookup:\n\n# Format stdin using config from ./src directory\necho 'f(x,y)=x+y' | jlfmt --config-dir=./src\n\n# Useful in editor integrations to respect project config\ncat file.jl | jlfmt --config-dir=$(dirname file.jl)\n\nThe formatter will search for .JuliaFormatter.toml in the specified directory and its parent directories, just like it does for regular file inputs.","category":"section"},{"location":"cli/#Conventions","page":"Command Line Interface","title":"Conventions","text":"jlfmt follows standard CLI conventions:\n\nExit code 0 on success\nExit code 1 on formatting errors or when --check detects unformatted files\nFormatted output to stdout (default) or in-place with --inplace\nError messages to stderr","category":"section"},{"location":"api/#API-Documentation","page":"API Reference","title":"API Documentation","text":"","category":"section"},{"location":"api/#JuliaFormatter.AlignGroup","page":"API Reference","title":"JuliaFormatter.AlignGroup","text":"AlignGroup\n\nGroup of FST node indices and required metadata to potentially align them.\n\n- `node_inds`. Indices of FST nodes affected by alignment.\n- `nodes`. FST nodes affected by alignment.\n- `line_offsets`. Line offset of the character nodes may be aligned to\nin the source file.\n- `lens`. Length of the FST node prior to the alignment character. Used\nto calculate extra whitespace padding.\n- `whitespaces`. Number of whitespaces between the alignment character and\nthe prior FST node. If this is > 1 it signifies additional whitespace was\nmanually added by the user since the formatter would only use 0 or 1 whitespaces.\n\n\n\n\n\n","category":"type"},{"location":"api/#JuliaFormatter.DefaultStyle","page":"API Reference","title":"JuliaFormatter.DefaultStyle","text":"DefaultStyle\n\nThe default formatting style. See the Style section of the documentation for more details.\n\nSee also: BlueStyle, YASStyle, SciMLStyle, MinimalStyle\n\n\n\n\n\n","category":"type"},{"location":"api/#JuliaFormatter.FST","page":"API Reference","title":"JuliaFormatter.FST","text":"Formatted Syntax Tree\n\n\n\n\n\n","category":"type"},{"location":"api/#JuliaFormatter.MinimalStyle","page":"API Reference","title":"JuliaFormatter.MinimalStyle","text":"MinimalStyle()\n\n\n\n\n\n","category":"type"},{"location":"api/#JuliaFormatter.add_node!-Tuple{JuliaFormatter.FST, JuliaFormatter.FST, JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.add_node!","text":"add_node!(\n    t::FST,\n    n::FST,\n    s::State;\n    join_lines::Bool = false,\n    max_padding::Int = -1,\n    override_join_lines_based_on_source::Bool = false,\n)\n\nAppends n to t.\n\njoin_lines if false a NEWLINE node will be added and n will appear\n\non the next line, otherwise it will appear on the same line as the previous node (when printing).\n\nmax_padding >= 0 indicates margin of t should be based on whether the margin\n\nof n + max_padding is greater than the current margin of t. Otherwise the margin n will be added to t.\n\noverride_join_lines_based_on_source is only used when join_lines_based_on_source option is true. In which\n\nn is added to t as if join_lines_based_on_source was false.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.align_binaryopcalls!-Tuple{JuliaFormatter.FST, Vector{Int64}}","page":"API Reference","title":"JuliaFormatter.align_binaryopcalls!","text":"align_binaryopcalls!(fst::FST, op_inds::Vector{Int})\n\nAligns binary operator expressions.\n\nAdditionally handles the case where a keyword such as const is used prior to the binary op call.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.align_conditional!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.align_conditional!","text":"align_conditional!(fst::FST)\n\nAligns a conditional expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.align_matrix!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.align_matrix!","text":"Adjust whitespace in between matrix elements such that it's the same as the original source file.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.align_struct!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.align_struct!","text":"align_struct!(fst::FST)\n\nAligns struct fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.annotate_typefields_with_any!-Tuple{JuliaFormatter.FST, JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.annotate_typefields_with_any!","text":"annotate_typefields_with_any!(fst::FST, s::State)\n\nAnnotates fields in a type definitions with ::Any if no type annotation is provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.binaryop_to_whereop!-Tuple{JuliaFormatter.FST, JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.binaryop_to_whereop!","text":"binaryop_to_whereop(fst::FST, s::State)\n\nHandles the case of a function def defined as:\n\nfoo(a::A)::R where A = body\n\nIn this case instead of it being parsed as (1):\n\nBinary\n - Where\n - OP\n - RHS\n\nIt's parsed as (2):\n\nBinary\n - Binary\n  - LHS\n  - OP\n  - Where\n   - R\n   - ...\n - OP\n - RHS\n\n(1) is preferrable since it's the same parsed result as:\n\nfoo(a::A) where A = body\n\nThis transformation converts (2) to (1).\n\nref https://github.com/julia-vscode/CSTParser.jl/issues/93\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.eq_to_in_normalization!-Tuple{JuliaFormatter.FST, Bool, String}","page":"API Reference","title":"JuliaFormatter.eq_to_in_normalization!","text":"eq_to_in_normalization!(fst::FST, always_for_in::Bool, for_in_replacement::String)\neq_to_in_normalization!(fst::FST, always_for_in::Nothing, for_in_replacement::String)\n\nTransforms\n\nfor i = iter body end\n\n=>\n\nfor i in iter body end\n\nAND\n\nfor i in 1:10 body end\n\n=>\n\nfor i = 1:10 body end\n\nalways_for_in=nothing disables this normalization behavior.\n\nhttps://github.com/domluna/JuliaFormatter.jl/issues/34\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.find_optimal_nest_placeholders-Tuple{JuliaFormatter.FST, Int64, Int64}","page":"API Reference","title":"JuliaFormatter.find_optimal_nest_placeholders","text":"Finds the optimal placeholders to turn into a newlines such that the length of the arguments on each line is as close as possible while following margin constraints.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.flatten_binaryopcall-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.flatten_binaryopcall","text":"Flattens a binary operation call tree if the operation repeats 2 or more times. \"a && b && c\" will be transformed while \"a && b\" will not.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format-Tuple{AbstractString, JuliaFormatter.AbstractStyle}","page":"API Reference","title":"JuliaFormatter.format","text":"format(path, style::AbstractStyle; options...)::Bool\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format-Tuple{Any}","page":"API Reference","title":"JuliaFormatter.format","text":"format(\n    paths; # a path or collection of paths\n    options...,\n)::Bool\n\nRecursively descend into files and directories, formatting any .jl, .md, .jmd, or .qmd files.\n\nSee format_file and format_text for a description of the options.\n\nThis function will look for .JuliaFormatter.toml in the location of the file being formatted, and searching up the file tree until a config file is (or isn't) found. When found, the configurations in the file will overwrite the given options. See Configuration File for more details.\n\nOutput\n\nReturns a boolean indicating whether the file was already formatted (true) or not (false).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format-Tuple{Module}","page":"API Reference","title":"JuliaFormatter.format","text":"format(mod::Module, args...; options...)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format_file-Tuple{AbstractString}","page":"API Reference","title":"JuliaFormatter.format_file","text":"format_file(\n    filename::AbstractString;\n    overwrite::Bool = true,\n    verbose::Bool = false,\n    format_markdown::Bool = false,\n    format_options...,\n)::Bool\n\nFormats the contents of filename assuming it's a .jl, .md, .jmd or .qmd file.\n\nSee https://domluna.github.io/JuliaFormatter.jl/dev/#File-Options for details on available options.\n\nOutput\n\nReturns a boolean indicating whether the file was already formatted (true) or not (false).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format_md-Tuple{AbstractString}","page":"API Reference","title":"JuliaFormatter.format_md","text":"format_md(text::AbstractString; style::AbstractStyle = DefaultStyle(), kwargs...)\n\nNormalizes the Markdown source and formats Julia code blocks.\n\nSee format_text for description of formatting options.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format_text-Tuple{AbstractString}","page":"API Reference","title":"JuliaFormatter.format_text","text":"format_text(\n    text::AbstractString;\n    style::AbstractStyle = DefaultStyle(),\n    indent::Int = 4,\n    margin::Int = 92,\n    options...,\n)::String\n\nFormats a Julia source passed in as a string, returning the formatted code as another string.\n\nSee https://domluna.github.io/JuliaFormatter.jl/dev/#Formatting-Options for details on available options.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.is_iterable_arg-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.is_iterable_arg","text":"Returns whether fst can be an iterable argument. For example in the case of a function call, which is of type Call:\n\n(a, b, c; k1=v1)\n\nThis would return true for a, b, c and k1=v1 and false for all other nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.length_to-Tuple{JuliaFormatter.FST, Any}","page":"API Reference","title":"JuliaFormatter.length_to","text":"`length_to(x::FST, ntyps; start::Int = 1)`\n\nReturns the length to any node type in ntyps based off the start index.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.long_to_short_function_def!-Tuple{JuliaFormatter.FST, JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.long_to_short_function_def!","text":"long_to_short_function_def!(fst::FST, s::State)\n\nTransforms a long function definition\n\nfunction f(arg2, arg2)\n    body\nend\n\nto a short function definition\n\nf(arg1, arg2) = body\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.move_at_sign_to_the_end-Tuple{JuliaFormatter.FST, JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.move_at_sign_to_the_end","text":"move_at_sign_to_the_end(fst::FST, s::State)\n\nNOTE: Assumes fst is the caller name of a macrocall such as @macro or Module.@macro.\n\nMoves @ to the last identifier.\n\nExample:\n\n@Module.macro\n\nto\n\nModule.@macro\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.nest_if_over_margin!-Tuple{JuliaFormatter.AbstractStyle, JuliaFormatter.FST, JuliaFormatter.State, Int64, Vector{Tuple{JuliaFormatter.FNode, Union{Nothing, JuliaFormatter.Metadata}}}}","page":"API Reference","title":"JuliaFormatter.nest_if_over_margin!","text":"nest_if_over_margin!(\n    style,\n    fst::FST,\n    s::State,\n    idx::Int;\n    stop_idx::Union{Int,Nothing} = nothing,\n)::Bool\n\nConverts the node at idx to a NEWLINE if the current margin plus the additional margin from fst[idx:stop_idx-1] is greater than the allowed margin.\n\nIf stop_idx == nothing the range is fst[idx:end].\n\nReturns whether nesting occurred.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.pipe_to_function_call_pass!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.pipe_to_function_call_pass!","text":"pipe_to_function_call_pass!(fst::FST)\n\nRewrites x |> f to f(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.prepend_return!-Tuple{JuliaFormatter.FST, JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.prepend_return!","text":"prepend_return!(fst::FST, s::State)\n\nPrepends return to the last expression of a block if applicable.\n\nfunction foo()\n    a = 2 * 3\n    a / 3\nend\n\nto\n\nfunction foo()\n    a = 2 * 3\n    return a / 3\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.remove_superfluous_whitespace!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.remove_superfluous_whitespace!","text":"remove_superfluous_whitespace!(fst::FST)\n\nSoft deletes WHITESPACE or PLACEHOLDER that's directly followed by a NEWLINE or INLINECOMMENT node.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.separate_kwargs_with_semicolon!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.separate_kwargs_with_semicolon!","text":"separate_kwargs_with_semicolon!(fst::FST)\n\nEnsures keyword arguments are separated by a \";\".\n\nExamples\n\nReplace \",\" with \";\".\n\na = f(x, y = 3)\n\n->\n\na = f(x; y = 3)\n\nMove \";\" to the prior to the first positional argument.\n\na = f(x = 1; y = 2)\n\n->\n\na = f(; x = 1, y = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.short_to_long_function_def!-Tuple{JuliaFormatter.FST, JuliaFormatter.State, Vector{Tuple{JuliaFormatter.FNode, Union{Nothing, JuliaFormatter.Metadata}}}}","page":"API Reference","title":"JuliaFormatter.short_to_long_function_def!","text":"short_to_long_function_def!(fst::FST, s::State)\n\nTransforms a short function definition\n\nf(arg1, arg2) = body\n\nto a long function definition\n\nfunction f(arg2, arg2)\n    body\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.unnestable_node-Tuple{JuliaSyntax.GreenNode}","page":"API Reference","title":"JuliaFormatter.unnestable_node","text":"cst is assumed to be a single child node. Returnss true if the node is of the syntactic form {...}, [...], or (...).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.walk-Tuple{Function, JuliaFormatter.FST, JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.walk","text":"walk(f, fst::FST, s::State)\n\nWalks fst calling f on each node.\n\nIn situations where descending further into a subtree is not desirable f should return a value other than nothing.\n\nnote: Note\nThis function mutates the State's (s) line_offset. If this is not desired you should save the value before calling this function and restore it after.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#Syntax-Tree-Transformations","page":"Syntax Transforms","title":"Syntax Tree Transformations","text":"","category":"section"},{"location":"transforms/#for-in-vs.-for","page":"Syntax Transforms","title":"for in vs. for =","text":"By default if the RHS is a range, i.e. 1:10 then for in is converted to for =. Otherwise for = is converted to for in. See this issue for the rationale and further explanation.\n\nAlternative to the above - setting always_for_in to true, i.e. format_text(..., always_for_in = true) will always convert = to in even if the RHS is a range. always_for_in=nothing will leave the choice of in vs = up to the user.","category":"section"},{"location":"transforms/#Trailing-Commas","page":"Syntax Transforms","title":"Trailing Commas","text":"If the node is iterable, for example a function call or list and is nested, a trailing comma is added to the last argument. The trailing comma is removed if unnested:\n\nfunc(a, b, c)\n\n->\n\nfunc(\n    a,\n    b,\n    c,\n)\n\nSee this issue for more details.","category":"section"},{"location":"transforms/#Trailing-Semicolons","page":"Syntax Transforms","title":"Trailing Semicolons","text":"If a matrix node is nested the semicolons are removed.\n\nA = [1 0; 0 1]\n\n->\n\nA = [\n    1 0\n    0 1\n]\n\nSee this issue for more details.","category":"section"},{"location":"transforms/#Leading-and-trailing-0s-for-float-literals","page":"Syntax Transforms","title":"Leading and trailing 0s for float literals","text":"If a float literal is missing a trailing 0 it is added:\n\na = 1.\n\n->\n\na = 1.0\n\nIf a float literal is missing a leading 0 it is added:\n\na = .1\n\n->\n\na = 0.1\n\nFor Float32 if there is no decimal point, .0 is added:\n\na = 1f0\n\n->\n\na = 1.0f0\n\nSee this issue for more details.","category":"section"},{"location":"transforms/#Surround-where-arguments-with-curly-brackets","page":"Syntax Transforms","title":"Surround where arguments with curly brackets","text":"If the arguments of a where call are not surrounded by curly brackets, they are added:\n\nfoo(x::T) where T = ...\n\n->\n\nfoo(x::T) where {T} = ...\n\nSee this issue for more details.","category":"section"},{"location":"transforms/#Annotate-unannotated-type-fields-with-Any","page":"Syntax Transforms","title":"Annotate unannotated type fields with Any","text":"struct Foo\n    field\nend\n\n->\n\nstruct Foo\n    field::Any\nend","category":"section"},{"location":"transforms/#Move-@-in-macro-calls-to-the-final-identifier","page":"Syntax Transforms","title":"Move @ in macro calls to the final identifier","text":"@Module.macro\n\n->\n\nModule.@macro","category":"section"},{"location":"custom_alignment/#Custom-Alignment","page":"Custom Alignment","title":"Custom Alignment","text":"Solution for issue 179\n\nCustom alignment is determined by a whitespace heuristic:\n\nA token (typically an operator, i.e. =, ?, ::, etc) is custom aligned if there are > 1 whitespaces from the previous expression since the formatter only outputs 0 or 1 whitespaces for separation. If custom alignment is determined then all expressions in the code block will be aligned to the furthest aligned token.\n\nNOTE: alignment overrides nesting behavior, meaning it ignores the allowed maximum margin","category":"section"},{"location":"custom_alignment/#Example","page":"Custom Alignment","title":"Example","text":"Suppose the source text is as follows\n\nconst variable1 = 1\nconst var2      = 2\nconst var3 = 3\nconst var4 = 4\nconst var5          = 5\n\nIf the align_assignment option is enabled the formatter will detect that var2 is aligned to variable1 AND var2 has several whitespaces (>1) prior to =. Since var3,var4, and var5 are part of the same code block (no comments or newlines separating code) they will also be aligned.\n\nSo the output would be\n\nconst variable1 = 1\nconst var2      = 2\nconst var3      = 3\nconst var4      = 4\nconst var5      = 5\n\nNotice how the = operator for var5 is correctly positioned despite it being located further to the right than other = operators.\n\nHowever, if the source code is\n\nconst variable1 = 1\nconst variable2 = 2\nconst var3 = 3\nconst var4 = 4\nconst var5 = 5\n\nIt's now ambiguous whether this is meant to be aligned and so the formatter will proceed with normal behavior.","category":"section"},{"location":"custom_alignment/#Alignment-Options","page":"Custom Alignment","title":"Alignment Options","text":"In order for alignment to occur the option must be set to true. Available options:\n\nalign_assignment\nalign_struct_field\nalign_conditional\nalign_pair_arrow\nalign_matrix\n\nCaveat: Since nesting is disabled when alignment occurs be careful when adding comments to the RHS expression. This will be fixed in a future release\n\nFor example:\n\nconst variable1 = 1\nconst var2      = foo(10,\n    # comment,\n    20)\n\nThis will be formatted to\n\nconst variable1 = 1\nconst var2      = foo(10, # comment, 20)\n\nwhich causes a parsing error.","category":"section"},{"location":"custom_alignment/#align_assignment","page":"Custom Alignment","title":"align_assignment","text":"Align to =-like operators. This covers variable assignments and short definition functions.\n\nconst UTF8PROC_STABLE    = (1 << 1)\nconst UTF8PROC_COMPAT    = (1 << 2)\nconst UTF8PROC_COMPOSE   = (1 << 3)\nconst UTF8PROC_DECOMPOSE = (1 << 4)\nconst UTF8PROC_IGNORE    = (1 << 5)\nconst UTF8PROC_REJECTNA  = (1 << 6)\nconst UTF8PROC_NLF2LS    = (1 << 7)\nconst UTF8PROC_NLF2PS    = (1 << 8)\nconst UTF8PROC_NLF2LF    = (UTF8PROC_NLF2LS | UTF8PROC_NLF2PS)\nconst UTF8PROC_STRIPCC   = (1 << 9)\nconst UTF8PROC_CASEFOLD  = (1 << 10)\nconst UTF8PROC_CHARBOUND = (1 << 11)\nconst UTF8PROC_LUMP      = (1 << 12)\nconst UTF8PROC_STRIP     = (1 << 13)\n\n\nvcat(X::T...) where {T}         = T[X[i] for i = 1:length(X)]\nvcat(X::T...) where {T<:Number} = T[X[i] for i = 1:length(X)]\nhcat(X::T...) where {T}         = T[X[j] for i = 1:1, j = 1:length(X)]\nhcat(X::T...) where {T<:Number} = T[X[j] for i = 1:1, j = 1:length(X)]\n\na  = 1\nbc = 2\n\nlong_variable = 1\nother_var     = 2","category":"section"},{"location":"custom_alignment/#align_struct_field","page":"Custom Alignment","title":"align_struct_field","text":"Align struct field definitions to :: or = - whichever has higher precedence.\n\nBase.@kwdef struct Options\n    indent::Int                            = 4\n    margin::Int                            = 92\n    always_for_in::Bool                    = false\n    whitespace_typedefs::Bool              = false\n    whitespace_ops_in_indices::Bool        = false\n    remove_extra_newlines::Bool            = false\n    import_to_using::Bool                  = false\n    pipe_to_function_call::Bool            = false\n    short_to_long_function_def::Bool       = false\n    always_use_return::Bool                = false\n    whitespace_in_kwargs::Bool             = true\n    annotate_untyped_fields_with_any::Bool = true\n    format_docstrings::Bool                = false\n    align_struct_fields::Bool              = false\n\n    # no custom whitespace so this block is not aligned\n    another_field1::BlahBlahBlah = 10\n    field2::Foo = 10\n\n    # no custom whitespace but single line blocks are not aligned\n    # either way\n    Options() = new()\nend\n\n\nmutable struct Foo\n    a             :: T\n    longfieldname :: T\nend","category":"section"},{"location":"custom_alignment/#align_conditional","page":"Custom Alignment","title":"align_conditional","text":"Align conditional expressions to either ?, :, or both.\n\n# This will remain like this if using YASStyle\nindex = zeros(n <= typemax(Int8)  ? Int8  :\n              n <= typemax(Int16) ? Int16 :\n              n <= typemax(Int32) ? Int32 : Int64, n)\n\n# Using DefaultStyle\nindex = zeros(\n    n <= typemax(Int8)  ? Int8  :\n    n <= typemax(Int16) ? Int16 :\n    n <= typemax(Int32) ? Int32 : Int64,\n    n,\n)\n\n# Note even if the maximum margin is set to 1, the alignment remains intact\nindex =\n    zeros(\n        n <= typemax(Int8)  ? Int8  :\n        n <= typemax(Int16) ? Int16 :\n        n <= typemax(Int32) ? Int32 : Int64,\n        n,\n    )\n","category":"section"},{"location":"custom_alignment/#align_pair_arrow","page":"Custom Alignment","title":"align_pair_arrow","text":"Align pair arrows (=>).\n\npages = [\n    \"Introduction\"        => \"index.md\",\n    \"How It Works\"        => \"how_it_works.md\",\n    \"Code Style\"          => \"style.md\",\n    \"Skipping Formatting\" => \"skipping_formatting.md\",\n    \"Syntax Transforms\"   => \"transforms.md\",\n    \"Custom Alignment\"    => \"custom_alignment.md\",\n    \"Custom Styles\"       => \"custom_styles.md\",\n    \"YAS Style\"           => \"yas_style.md\",\n    \"Configuration File\"  => \"config.md\",\n    \"API Reference\"       => \"api.md\",\n]","category":"section"},{"location":"custom_alignment/#align_matrix","page":"Custom Alignment","title":"align_matrix","text":"TLDR: If you want to align matrix elements yourself set this to true\n\nWhitespace surrounding matrix elements in the original source file is maintained. Differs from other alignment options since it does not try to \"detect\" alignment and then adjust other elements.\n\n# Elements left-aligned in original source\njulia> s = \"\"\"\n       a = [\n       100 300 400\n       1   eee 40000\n       2   α   b\n       ]\"\"\"\n\"a = [\\n100 300 400\\n1   eee 40000\\n2   α   b\\n]\"\n\njulia> format_text(s, align_matrix=true) |> print\na = [\n    100 300 400\n    1   eee 40000\n    2   α   b\n]\n\n# Elements right-aligned in original source\njulia> s = \"\"\"\n       a = [\n       100 300   400\n         1  ee 40000\n         2   a     b\n       ]\"\"\"\n\"a = [\\n100 300   400\\n  1  ee 40000\\n  2   a     b\\n]\"\n\njulia>\n\njulia> format_text(s, align_matrix=true) |> print\na = [\n    100 300   400\n      1  ee 40000\n      2   a     b\n]","category":"section"},{"location":"how_it_works/#How-It-Works","page":"How It Works","title":"How It Works","text":"The formatter takes a .jl file as input and produce a idealized, formatted .jl as output. Some formatters mutate the state of the current file, JuliaFormatter takes a different approach - first generating a canonical output, and then mutating that canonical output; adhering to the indent and margin constraints.","category":"section"},{"location":"how_it_works/#Generating-an-FST","page":"How It Works","title":"Generating an FST","text":"The source code is parsed with CSTParser.jl which returns a CST (Concrete Syntax Tree). A CST is a one-to-one mapping of the language to a tree form. In most cases a more compact AST (Abstract Syntax Tree) representation is desired. However, since formatting manipulate the source text itself, the richer representation of a CST is incredibly useful.\n\nOnce the CST is created it's then used to generate a FST (Formatted Syntax Tree).\n\nNote: this is not an actual term, just something I made up. Essentially it's a CST with additional formatting specific metadata.\n\nThe important part of an FST is any .jl file that is syntactically the same (whitespace is irrelevant) produce an identical FST.\n\nFor example:\n\n# p1.jl\na = \n       foo(a,                     b,           \n       c,d)\n\nand\n\n# p2.jl\na =                      foo(a,\nb,\nc,d)\n\nwill produce the same FST, which printed would look like:\n\n# fst output\na = foo(a, b, c, d)\n\nSo what does a typical FST look like?\n\nCode and comments are indented to match surrounding code blocks. Unnecessary whitespace is removed. Newlines in between code blocks are untouched.\n\nIf the expression can be put on a single line it will be. It doesn't matter it's a function call which 120 arguments, making it 1000 characters long. During this initial stage it will be put on a single line.\n\nIf the expression has a structure to it, such as a try, if, or 'struct' definition. It will be spread across multiple lines appropriately:\n\n\n# original source\ntry a1;a2 catch e b1;b2 finally c1;c2 end\n\n-> \n\n# printed FST\ntry\n   a1\n   a2\ncatch e\n   b1\n   b2\nfinally\n   c1\n   c2\nend\n\nWith this FST representation it's much easier to determine when and how lines should be broken.","category":"section"},{"location":"how_it_works/#Nesting-breaking-lines","page":"How It Works","title":"Nesting - breaking lines","text":"During the nesting stage and original FST is mutated to adhere to the margin specification.\n\nThroughout the previous stage, while the FST was being generated, PLACEHOLDER nodes were being inserted at various points. These can be converted to NEWLINE nodes during nesting, which is how lines are broken.\n\nAssume we had a function call which went over the margin.\n\nbegin\n    foo = funccall(argument1, argument2, ..., argument120) # way over margin limit !!!\nend\n\nIt would be nested to\n\nbegin\n    foo = funccall(\n        argument1,\n        argument2,\n        ...,\n        argument120\n    ) # way over margin limit !!!\nend\n\nYou can read how code is nested in the style section.\n\nOnce the FST has been nested it's then printed out to a file and voila! You have a formatted version of your code!","category":"section"},{"location":"skipping_formatting/#Skipping-Formatting","page":"Skipping Formatting","title":"Skipping Formatting","text":"By default formatting is always on but can be toggled with the following comments:\n\n#! format: off\n# Turns off formatting from this point onwards\n...\n\n#! format: on\n# Turns formatting back on from this point onwards\n\nThese can be used throughout a file, or, for an entire file not be formatted add \"format: off\" at the top of the file:\n\n#! format: off\n#\n# It doesn't actually matter if it's on\n# the first line of the line but anything\n# onwards will NOT be formatted.\n\nmodule Foo\n...\nend\n\nnote: Ignoring files\nYou can also ignore entire files and directories by supplying the ignore option in .JuliaFormatter.toml.\n\nNote the formatter expects #! format: on and #! format: off to be on its own line and the whitespace to be an exact match.","category":"section"},{"location":"#JuliaFormatter.jl","page":"Introduction","title":"JuliaFormatter.jl","text":"Width-sensitive formatter for Julia code. Inspired by gofmt, refmt, black, and prettier. Built with CSTParser.jl.\n\nSane defaults out of the box with options to customize.\nSupports YAS, Blue and SciML style guides.\n.JuliaFormatter.toml configuration file to store options.\n\n(Image: )","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"]add JuliaFormatter","category":"section"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"julia> using JuliaFormatter\n\n# Recursively formats all Julia files in the current directory\njulia> format(\".\")\n\n# Formats an individual file\njulia> format_file(\"foo.jl\")\n\n# Formats a string (contents of a Julia file)\njulia> format_text(str)\n\nCheck out the docs for further description of the formatter and its options.\n\nUse With GitHub Actions","category":"section"},{"location":"#Formatting-Options","page":"Introduction","title":"Formatting Options","text":"","category":"section"},{"location":"#indent","page":"Introduction","title":"indent","text":"default: 4\n\nThe number of spaces used for an indentation.","category":"section"},{"location":"#margin","page":"Introduction","title":"margin","text":"default: 92\n\nThe maximum length of a line. Code exceeding this margin will be formatted across multiple lines.","category":"section"},{"location":"#always_for_in","page":"Introduction","title":"always_for_in","text":"default: false\n\nIf true, = is always replaced with in if part of a for loop condition. For example, for i = 1:10 will be transformed to for i in 1:10. Set this to nothing to leave the choice to the user.","category":"section"},{"location":"#whitespace_typedefs","page":"Introduction","title":"whitespace_typedefs","text":"default: false\n\nIf true, whitespace is added for type definitions. Make this true if you prefer Union{A <: B, C} to Union{A<:B,C}.","category":"section"},{"location":"#whitespace_ops_in_indices","page":"Introduction","title":"whitespace_ops_in_indices","text":"default: false\n\nIf true, whitespace is added for binary operations in indices. Make this true if you prefer arr[a + b] to arr[a+b]. Additionally, if there's a colon : involved, parenthesis will be added to the LHS and RHS.\n\nExample: arr[(i1 + i2):(i3 + i4)] instead of arr[i1+i2:i3+i4].","category":"section"},{"location":"#remove_extra_newlines","page":"Introduction","title":"remove_extra_newlines","text":"default: false\n\nIf true, superfluous newlines will be removed. For example:\n\nmodule M\n\n\n\na = 1\n\nfunction foo()\n\n\n    return nothing\n\nend\n\n\nb = 2\n\n\nend\n\nis rewritten as\n\nmodule M\n\na = 1\n\nfunction foo()\n    return nothing\nend\n\nb = 2\n\nend\n\nModules are the only type of code block allowed to keep a single newline prior to the initial or after the final piece of code.","category":"section"},{"location":"#import_to_using","page":"Introduction","title":"import_to_using","text":"default: false\n\nIf true, import expressions are rewritten to using expressions in the following cases:\n\nimport A\n\nimport A, B, C\n\nis rewritten to:\n\nusing A: A\n\nusing A: A\nusing B: B\nusing C: C\n\nExceptions:\n\nIf as is found in the import expression. using CANNOT be used in this context. The following example will NOT BE rewritten.\n\nimport Base.Threads as th\n\nIf import is used in the following context it is NOT rewritten. This may change in a future patch.\n\n@everywhere import A, B","category":"section"},{"location":"#pipe_to_function_call","page":"Introduction","title":"pipe_to_function_call","text":"default: false\n\nIf true, x |> f is rewritten to f(x).","category":"section"},{"location":"#short_to_long_function_def","page":"Introduction","title":"short_to_long_function_def","text":"default: false\n\nTransforms a short function definition\n\nf(arg1, arg2) = body\n\nto a long function definition if the short function definition exceeds the maximum margin. Or if force_long_function_def is set to true.\n\nfunction f(arg2, arg2)\n    body\nend","category":"section"},{"location":"#force_long_function_def","page":"Introduction","title":"force_long_function_def","text":"default: false\n\nIf true tweaks the behavior of short_to_long_function_def to force the transformation no matter how short the function definition is.","category":"section"},{"location":"#long_to_short_function_def","page":"Introduction","title":"long_to_short_function_def","text":"default: false\n\nTransforms a long function definition\n\nfunction f(arg2, arg2)\n    body\nend\n\nto a short function definition if the short function definition does not exceed the maximum margin.\n\nf(arg1, arg2) = body","category":"section"},{"location":"#always_use_return","page":"Introduction","title":"always_use_return","text":"default: false\n\nIf true, return will be prepended to the last expression where applicable in function definitions, macro definitions, and do blocks.\n\nExample:\n\nfunction foo()\n    expr1\n    expr2\nend\n\nto\n\nfunction foo()\n    expr1\n    return expr2\nend","category":"section"},{"location":"#whitespace_in_kwargs","page":"Introduction","title":"whitespace_in_kwargs","text":"default: true\n\nIf true, = in keyword arguments will be surrounded by whitespace.\n\nf(; a=4)\n\nto\n\nf(; a = 4)\n\nAn exception to this is if the LHS ends with \"!\" then even if whitespace_in_kwargs is false, = will still be surrounded by whitespace. The logic behind this intervention being on the following parse the ! will be treated as part of =, as in a \"not equal\" binary operation. This would change the semantics of the code and is therefore disallowed.","category":"section"},{"location":"#annotate_untyped_fields_with_any","page":"Introduction","title":"annotate_untyped_fields_with_any","text":"default: true\n\nAnnotates fields in a type definitions with ::Any if no type annotation is provided:\n\nstruct A\n    arg1\nend\n\nto\n\nstruct A\n    arg1::Any\nend","category":"section"},{"location":"#format_docstrings","page":"Introduction","title":"format_docstrings","text":"default: false\n\nFormat code docstrings with the same options used for the code source.\n\nMarkdown is formatted with CommonMark alongside Julia code.","category":"section"},{"location":"#align_*","page":"Introduction","title":"align_*","text":"default: false\n\nSee Custom Alignment documentation.","category":"section"},{"location":"#conditional_to_if","page":"Introduction","title":"conditional_to_if","text":"default: false\n\nIf the conditional E ? A : B exceeds the maximum margin converts it into the equivalent if block:\n\nif E\n    A\nelse\n    B\nend","category":"section"},{"location":"#normalize_line_endings","page":"Introduction","title":"normalize_line_endings","text":"default: \"auto\"\n\nOne of \"unix\" (normalize all \\r\\n to \\n), \"windows\" (normalize all \\n to \\r\\n), \"auto\" (automatically choose based on which line ending is more common in the file).","category":"section"},{"location":"#trailing_comma","page":"Introduction","title":"trailing_comma","text":"default: true\n\nOne of true, false, or nothing.\n\nTrailing commas are added after the final argument when nesting occurs and the closing punctuation appears on the next line.\n\nFor example when the following is nested (assuming DefaultStyle):\n\nfunccall(arg1, arg2, arg3)\n\nit turns into:\n\nfunccall(\n    arg1,\n    arg2,\n    arg3, # trailing comma added after `arg3` (final argument) !!!\n)\n\nWhen set to true, the trailing comma is always added during nesting.\nWhen set to false, the trailing comma is always removed during nesting.\nWhen set to nothing, the trailing comma appears as it does in the original source.","category":"section"},{"location":"#trailing_zero","page":"Introduction","title":"trailing_zero","text":"default: true\n\nAdd a trailing zero, if needed.","category":"section"},{"location":"#join_lines_based_on_source","page":"Introduction","title":"join_lines_based_on_source","text":"default: false\n\nWhen true lines are joined as they appear in the original source file.\n\nfunction foo(arg1,\n                       arg2, arg3\n                       )\n       body\nend\n\nWhen false and the maximum margin is > than the length of \"function foo(arg1, arg2, arg3)\" this is formatted to\n\nfunction foo(arg1, arg2, arg3)\n    body\nend\n\nWhen true, arg1 and arg2, arg3 will remain on separate lines even if they can fit on the same line since it's within maximum margin. The indentation is dependent on the style.\n\nfunction foo(arg1,\n    arg2, arg3,\n)\nend\n\nThere are exceptions to this:\n\nif a body1 elseif b body2 else body3 end\n\nwill be formatted to the following, even if this option is set to true:\n\nif a\n    body1\nelseif b\n    body2\nelse\n    body3\nend\n\nwarning: Warning\nThe maximum margin still applies even when this option is set to true.","category":"section"},{"location":"#indent_submodule","page":"Introduction","title":"indent_submodule","text":"default: false\n\nWhen set to true, submodule(s) appearing in the same file will be indented.\n\nmodule A\na = 1\n\nmodule B\nb = 2\nmodule C\nc = 3\nend\nend\n\nd = 4\n\nend\n\nwill be formatted to:\n\nmodule A\na = 1\n\nmodule B\n    b = 2\n    module C\n        c = 3\n    end\nend\n\nd = 4\n\nend","category":"section"},{"location":"#separate_kwargs_with_semicolon","page":"Introduction","title":"separate_kwargs_with_semicolon","text":"default: false\n\nWhen set to true, keyword arguments in a function call will be separated with a semicolon.\n\nf(a, b=1)\n\n->\n\nf(a; b=1)","category":"section"},{"location":"#surround_whereop_typeparameters","page":"Introduction","title":"surround_whereop_typeparameters","text":"default: true\n\nSurrounds type parameters with curly brackets when set to true if the brackets are not already present.\n\nfunction func(...) where TPARAM\nend\n\n->\n\nfunction func(...) where {TPARAM}\nend","category":"section"},{"location":"#for_in_replacement","page":"Introduction","title":"for_in_replacement","text":"Can be used when always_for_in is true to replace the default in with ∈ (\\\\in), or = instead. The replacement options are (\"in\", \"=\", \"∈\").\n\nfor a = 1:10\nend\n\n# formatted with always_for_in = true, for_in_replacement = \"∈\"\nfor a ∈ 1:10\nend","category":"section"},{"location":"#variable_call_indent-and-and-yas_style_nesting","page":"Introduction","title":"variable_call_indent && yas_style_nesting","text":"The SciMLStyle supports the additional options variable_call_indent and yas_style_nesting.\n\nThe option variable_call_indent is set to [] by default. It allows calls without aligning to the opening parenthesis:\n\n# Allowed with and without `Dict in variable_call_indent`\nDict{Int, Int}(1 => 2,\n    3 => 4)\n\n# Allowed when `Dict in variable_call_indent`, but\n# will be changed to the first example when `Dict ∉ variable_call_indent`.\nDict{Int, Int}(\n    1 => 2,\n    3 => 4)\n\nThe option yas_style_nesting is set to false by default. Setting it to true makes the SciMLStyle use the YASStyle nesting rules:\n\n# With `yas_style_nesting = false`\nfunction my_large_function(argument1, argument2,\n    argument3, argument4,\n    argument5, x, y, z)\n    foo(x) + goo(y)\nend\n\n# With `yas_style_nesting = true`\nfunction my_large_function(argument1, argument2,\n                           argument3, argument4,\n                           argument5, x, y, z)\n    foo(x) + goo(y)\nend","category":"section"},{"location":"#short_circuit_to_if","page":"Introduction","title":"short_circuit_to_if","text":"You can convert short circuit expressions to the equivalent if expression.\n\nfunction foo(a, b)\n    a || return \"bar\"\n\n    \"hello\"\n\n    b && return \"ooo\"\nend\n\nBECOMES\n\nfunction foo(a, b)\n    if !(a)\n        return \"bar\"\n    end\n\n    \"hello\"\n\n    if b\n        return \"ooo\"\n    else\n        false\n    end\nend","category":"section"},{"location":"#disallow_single_arg_nesting","page":"Introduction","title":"disallow_single_arg_nesting","text":"Prevents the nesting of a single argument arg in parenthesis, brackets, and curly braces.\n\n# Without `disallow_single_arg_nesting`:\nfunction_call(\n    \"String argument\"\n)\n[array_item(\n    10\n)]\n{key => value(\n    \"String value\"\n)}\n\n# With `disallow_single_arg_nesting` enabled:\nfunction_call(\"String argument\")\n[array_item(10)]\n{key => value(\"String value\")}","category":"section"},{"location":"#File-Options","page":"Introduction","title":"File Options","text":"","category":"section"},{"location":"#overwrite","page":"Introduction","title":"overwrite","text":"default: true\n\nIf true the file will be reformatted in place, overwriting the existing file; if it is false, the formatted version of foo.jl will not be written anywhere.","category":"section"},{"location":"#verbose","page":"Introduction","title":"verbose","text":"default: false\n\nIf true details related to formatting the file will be printed to stdout.","category":"section"},{"location":"#format_markdown","page":"Introduction","title":"format_markdown","text":"default: false\n\nIf true, Markdown files are also formatted. Julia code blocks will be formatted in addition to the Markdown being normalized.","category":"section"},{"location":"#ignore","page":"Introduction","title":"ignore","text":"An array of paths to files and directories (with possible Glob wildcards) which will not be formatted.","category":"section"},{"location":"#Special-Format-Comments","page":"Introduction","title":"Special Format Comments","text":"","category":"section"},{"location":"#Turn-off/on-formatting","page":"Introduction","title":"Turn off/on formatting","text":"You can skip sections of code by using the #! format: off and #! format: on comments.\n\n\n# this should be formatted\na = f(aaa, bbb, ccc)\n\n# this should not be formatted\n#! format: off\na = f(aaa,\n    bbb,ccc)\n\nc = 102000\n\nd = @foo 10 20\n\ne = \"what the foocho\"\n#! format: on\n\n# this should be formatted\na = f(aaa, bbb, ccc)\n\n# ok\n\nIf you wish to not format an entire file just add #! format: off to the top of the file.","category":"section"},{"location":"#Stopping-a-block-of-code-from-indenting","page":"Introduction","title":"Stopping a block of code from indenting","text":"Sometimes you may wish for a block of code to not be indented. You can achieve this with #! format: noindent.\n\nbegin\n@muladd begin\n    #! format: noindent\n    a = 10\n    b = 20\n    begin\n       # another indent\n        z = 33\n    end\n\n    a * b\nend\n        end\n\nis formatted to\n\nbegin\n    @muladd begin\n    #! format: noindent\n    a = 10\n    b = 20\n    begin\n        # another indent\n        z = 33\n    end\n\n    a * b\n    end\nend\n\nNotice the contents of @muladd begin is not indented.\n\n#! format: noindent can also be nested.","category":"section"},{"location":"#Editor-Plugins","page":"Introduction","title":"Editor Plugins","text":"For integration with other editors:\n\nVSCode\nEmacs\nVim\nAtom (deprecated)","category":"section"}]
}
