var documenterSearchIndex = {"docs":
[{"location":"config/","page":"Configuration File","title":"Configuration File","text":"CurrentModule = JuliaFormatter","category":"page"},{"location":"config/#Configuration-File","page":"Configuration File","title":"Configuration File","text":"","category":"section"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"From v0.4.3, JuliaFormatter offers .prettierrc style configuration file support. This means you can specify formatting options shown in format_text in .JuliaFormatter.toml file and share that with others.","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"When format called, it will look for .JuliaFormatter.toml in the location of the file being formatted, and searching up the file tree until a config file is (or isn't) found. When found, the configurations in the file will overwrite the given options.","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"note: Note\nJuno, a Julia IDE that offers formatting feature using this package, also respects configuration file. When you use Julia-Client: Format-Code command, Juno will automatically search for a configuration file with the same rule as format does from the directory of current editor.","category":"page"},{"location":"config/#Basic-Configuration","page":"Configuration File","title":"Basic Configuration","text":"","category":"section"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"In .JuliaFormatter.toml, you can specify any of the formatting options shown in format_text in TOML, e.g. if you have","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"somedir/.JuliaFormatter.toml","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"indent = 2\nmargin = 100","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"then files under somedir will be formatted with 2 spaces indentation and the maximum line length 100.","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"warning: Custom Style\nCurrently the configuration file doesn't support user-defined Custom Styles. For the time being, we only provide specs for YAS Style and Blue Style in configuration file. In order to use YAS style instead of the default style, you can just specify:.JuliaFormatter.toml...\nstyle = \"yas\"\n...In the same way as above, you can specify style = \"blue\" to use Blue style.","category":"page"},{"location":"config/#Search-Rule","page":"Configuration File","title":"Search Rule","text":"","category":"section"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":".JuliaFormatter.toml will be searched up from the directory of the file being formatted. So if you have:","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"dir\n├─ .JuliaFormatter.toml\n├─ code.jl\n└─ subdir\n   └─ sub_code.jl","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"then format(\"subdir/sub_code.jl\") will be automatically configured by the dir/.JuliaFormatter.toml, as well as format(\"dir\") will format both dir/code.jl and dir/subdir/sub_code.jl according to the same configuration.","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"What will happen when we have multiple .JuliaFormatter.toml files ? In that case, the deepest configuration has the precedence. For example, if you have","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"dir\n├─ .JuliaFormatter.toml\n├─ code.jl\n├─ subdir1\n│  ├─ .JuliaFormatter.toml\n│  └─ sub_code1.jl\n└─ subdir2\n   └─ sub_code2.jl","category":"page"},{"location":"config/","page":"Configuration File","title":"Configuration File","text":"and call format(\"dir\"), code.jl and sub_code2.jl will be formatted according to the rules defined in dir/.JuliaFormatter.toml, while formatting sub_code1.jl will be configured by dir/subdir1/.JuliaFormatter.toml.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"CurrentModule = JuliaFormatter","category":"page"},{"location":"style/#Style","page":"Code Style","title":"Style","text":"","category":"section"},{"location":"style/","page":"Code Style","title":"Code Style","text":"This is meant to give an impression of how the ouput of a formatted file looks like. Additional examples can be found in the test files.","category":"page"},{"location":"style/#Initial-FST","page":"Code Style","title":"Initial FST","text":"","category":"section"},{"location":"style/","page":"Code Style","title":"Code Style","text":"All examples assume indentation of 4 spaces","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Functions, macros, structs with no arguments are placed on a single line:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"function  foo\nend\n\n->\n\nfunction foo end","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"This also applies to abstract and primitive types:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"abstract type\nAbstractFoo\nend\n\n->\n\nabstract type AbstractFoo end","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Functions calls foo(args...), tuples (args...), arrays [args...], braces {args...}, struct or where definitions Foo{args...} are placed on a single line. This applies to any code which has opening and closing punctuation: (...), {...}, [...].","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"f(\n\na,b\n\n,c )\n\n->\n\nf(a, b, c)","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"By default type definitions have no whitespace after commas:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Foo{\na,b\n,c }\n\n->\n\nFoo{a,b,c}","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Blocks and their bodies are spread across multiple lines properly indented.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Example 1:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"begin\n  a\n    b; c\n       end\n\n->\n\nbegin\n    a\n    b\n    c\nend","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Example 2:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"struct Foo{A, B}\n a::A\n  b::B\nend\n\n->\n\nstruct Foo{A,B}\n    a::A\n    b::B\nend","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Binary calls are placed on a single line and separated by whitespace. The exception to this are colon operations and operations inside an indexing expression. The latter being optional.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Example 1:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"a+b\n\n-> \n\na + b","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Example 2:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"a : a : c\n\n->\n\na:b:c","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Example 3:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"list[a + b]\n\n->\n\nlist[a+b]","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Conditionals are placed on a single line and separated by whitespace.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"cond1 ?\nexpr1 :     expr2\n\n->\n\ncond1 ? expr1 : expr2","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Comments are aligned to surrounding code blocks.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"# comment\nif a\n# comment\nelseif b\n# comment\nelseif c\n# comment\nelse\n# comment\nend\n# comment\n\n->\n\n# comment\nif a\n    # comment\nelseif b\n    # comment\nelseif c\n    # comment\nelse\n    # comment\nend\n# comment","category":"page"},{"location":"style/#Nesting-FST","page":"Code Style","title":"Nesting FST","text":"","category":"section"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Binary operations and conditionals are nested back-to-front.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Example 1:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"arg1 + arg2\n\n->\n\narg1 + \narg2","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Example 2:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"cond ? e1 : e2\n\n->\n\ncond ? e1 :\ne2\n\n->\n\ncond ? \ne1 :\ne2","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"If nesting is required for a = binary operation, the RHS is placed on the following line and indented.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"foo() = body\n\n->\n\nfoo() =\n    body","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Lazy && and || operations are nested according to is_standalone_shortcircuit rules.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"All arguments of a function call (applies to any opening/closing punctuation type) are nested if the expression exceeds the margin. The arguments are indented one level.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"function longfunctionname_that_is_long(lots, of, args, even, more, args)\n    body\nend\n\n->\n\nfunction longfunctionname_that_is_long(\n    lots, \n    of, \n    args,\n    even, \n    more, \n    args,\n)\n    body\nend","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"With where operations (A where B), A is nested prior to B.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"function f(arg1::A, key1 = val1; key2 = val2) where {A,B,C}\n    body\nend\n\n->\n\nfunction f(\n    arg1::A,\n    key1 = val1;\n    key2 = val2,\n) where {A,B,C}\n    body\nend\n\n-> \n\nfunction f(\n    arg1::A,\n    key1 = val1;\n    key2 = val2,\n) where {\n    A,\n    B,\n    C,\n}\n    body\nend","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"If a comment is detected inside of an expression, that expression is automatically nested:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"var = foo(\n    a, b, # comment\n    c,\n)\n\n->\n\nvar = foo(\n    a,\n    b, # comment\n    c,\n)","category":"page"},{"location":"style/#Unnesting-FST","page":"Code Style","title":"Unnesting FST","text":"","category":"section"},{"location":"style/","page":"Code Style","title":"Code Style","text":"In certain cases it's desirable to unnest parts of a FST.","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Example 1:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"# short function def\nfunction foo(arg1, arg2, arg3) = body\n\n-> \n\nfunction foo(arg1, arg2, arg3) =\n    body\n\n->\n\nfunction foo(\n    arg1,\n    arg2,\n    arg3,\n) =\n    body\n\n# If the margin allows it, `body` will be joined back\n# with the previous line.\n\nfunction foo(\n    arg1,\n    arg2,\n    arg3,\n) = body","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"Example 2:","category":"page"},{"location":"style/","page":"Code Style","title":"Code Style","text":"var = funccall(arg1, arg2, arg3)\n\n-> \n\nvar =\n    funccall(arg1, arg2, arg3)\n\n->\n\nvar =\n    funccall(\n        arg1,\n        arg2,\n        arg3,\n    )\n\n# If the margin allows it, the RHS will be joined back\n# with the previous line.\n\nvar = funccall(\n    arg1,\n    arg2,\n    arg3,\n)","category":"page"},{"location":"yas_style/#YAS-Style","page":"YAS Style","title":"YAS Style","text":"","category":"section"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"YASStyle","category":"page"},{"location":"yas_style/#JuliaFormatter.YASStyle","page":"YAS Style","title":"JuliaFormatter.YASStyle","text":"YASStyle()\n\nFormatting style based on YASGuide and JuliaFormatter#198.\n\nConfigurable options with different defaults to DefaultStyle are:\n\nalways_for_in = true\nwhitespace_ops_in_indices = true\nremove_extra_newlines = true\nimport_to_using = true\npipe_to_function_call = true\nshort_to_long_function_def = true\nalways_use_return = true\nwhitespace_in_kwargs = false\n\n\n\n\n\n","category":"type"},{"location":"yas_style/#Configuration-File-Example","page":"YAS Style","title":"Configuration File Example","text":"","category":"section"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"The .JuliaFormatter.toml which represents these settings is","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"style = \"yas\"","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"Or to use YASStyle except change one of the settings:","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"style = \"yas\"\nremove_extra_newlines = false","category":"page"},{"location":"yas_style/#Direct-Usage","page":"YAS Style","title":"Direct Usage","text":"","category":"section"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"format(\"file.jl\", YASStyle())","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"Or to use YASStyle except change one of the settings:","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"format(\"file.jl\", YASStyle(), remove_extra_newlines=false)","category":"page"},{"location":"yas_style/#Differences-from-DefaultStyle","page":"YAS Style","title":"Differences from DefaultStyle","text":"","category":"section"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"There are three main differences between YASStyle and DefaultStyle. They are based on alignment and line break behaviors.","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"Arguments are aligned to just after the start of the opener [, {, (, etc.","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"function_call(arg1,\n              arg2)","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"As you can see from the above the closer sticks to the final argument.\nNesting (line breaks) only occur when the margin of the next argument exceeds the maximim limit.","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"function_call(arg1, arg2,\n              arg3)","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"arg3 exceeded the margin limit and so it was placed on the following line.","category":"page"},{"location":"yas_style/#Nesting","page":"YAS Style","title":"Nesting =","text":"","category":"section"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"Unlike DefaultStyle, assignment operations = are not nested. That is, the following","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"my_function(arg1, arg2) = arg1 * arg2","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"Is not nested to","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"my_function(arg1, arg2) =\n    arg1 * arg2","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"It is highly recommended setting short_to_long_function_def to true. This option transforms the above to a long function definition if it exceeds the maximum margin.","category":"page"},{"location":"yas_style/","page":"YAS Style","title":"YAS Style","text":"function my_function(arg1, arg2)\n    arg1 * arg2\nend","category":"page"},{"location":"blue_style/#Blue-Style","page":"Blue Style","title":"Blue Style","text":"","category":"section"},{"location":"blue_style/","page":"Blue Style","title":"Blue Style","text":"BlueStyle","category":"page"},{"location":"blue_style/#JuliaFormatter.BlueStyle","page":"Blue Style","title":"JuliaFormatter.BlueStyle","text":"BlueStyle()\n\nFormatting style based on BlueStyle and JuliaFormatter#283.\n\nnote: Note\nThis style is still work-in-progress, and does not yet implement all of the BlueStyle guide.\n\nConfigurable options with different defaults to DefaultStyle are:\n\nalways_use_return = true\nshort_to_long_function_def = true\nwhitespace_ops_in_indices = true\nremove_extra_newlines = true\nalways_for_in = true\nimport_to_using = true\npipe_to_function_call = true\nwhitespace_in_kwargs = false\nannotate_untyped_fields_with_any = false\n\n\n\n\n\n","category":"type"},{"location":"blue_style/#Configuration-File-Example","page":"Blue Style","title":"Configuration File Example","text":"","category":"section"},{"location":"blue_style/","page":"Blue Style","title":"Blue Style","text":"The .JuliaFormatter.toml which represents these settings is","category":"page"},{"location":"blue_style/","page":"Blue Style","title":"Blue Style","text":"style = \"blue\"","category":"page"},{"location":"blue_style/","page":"Blue Style","title":"Blue Style","text":"Or to use BlueStyle except change one of the settings:","category":"page"},{"location":"blue_style/","page":"Blue Style","title":"Blue Style","text":"style = \"blue\"\nremove_extra_newlines = false","category":"page"},{"location":"blue_style/#Direct-Usage","page":"Blue Style","title":"Direct Usage","text":"","category":"section"},{"location":"blue_style/","page":"Blue Style","title":"Blue Style","text":"format(\"file.jl\", BlueStyle())","category":"page"},{"location":"blue_style/","page":"Blue Style","title":"Blue Style","text":"Or to use BlueStyle except change one of the settings:","category":"page"},{"location":"blue_style/","page":"Blue Style","title":"Blue Style","text":"format(\"file.jl\", BlueStyle(), remove_extra_newlines=false)","category":"page"},{"location":"api/#API-Documentation","page":"API Reference","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [JuliaFormatter]\nFilter = t -> (t != YASStyle && t != BlueStyle)  # on their own pages","category":"page"},{"location":"api/#JuliaFormatter.AlignGroup","page":"API Reference","title":"JuliaFormatter.AlignGroup","text":"AlignGroup\n\nGroup of FST node indices and required metadata to potentially align them.\n\n- `node_idxs`. Indices of FST nodes affected by alignment.\n- `line_offsets`. Line offset of the character nodes may be aligned to\nin the source file.\n- `lens`. Length of the FST node prior to the alignment character. Used\nto calculate extra whitespace padding.\n- `whitespaces`. Number of whitespaces between the alignment character and\nthe prior FST node. If this is > 1 it signifies additional whitespace was\nmanually added by the user since the formatter would only use 0 or 1 whitespaces.\n\n\n\n\n\n","category":"type"},{"location":"api/#JuliaFormatter.DefaultStyle","page":"API Reference","title":"JuliaFormatter.DefaultStyle","text":"DefaultStyle\n\nThe default formatting style. See the Style section of the documentation for more details.\n\nSee also: BlueStyle, YASStyle\n\n\n\n\n\n","category":"type"},{"location":"api/#JuliaFormatter.FST","page":"API Reference","title":"JuliaFormatter.FST","text":"Formatted Syntax Tree\n\n\n\n\n\n","category":"type"},{"location":"api/#JuliaFormatter.add_node!-Tuple{JuliaFormatter.FST,JuliaFormatter.FST,JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.add_node!","text":"add_node!(\n    t::FST,\n    n::FST,\n    s::State;\n    join_lines::Bool = false,\n    max_padding::Int = -1,\n    override_join_lines_based_on_source::Bool = false,\n)\n\nAppends n to t.\n\njoin_lines if false a NEWLINE node will be added and n will appear\n\non the next line, otherwise it will appear on the same line as the previous node (when printing).\n\nmax_padding >= 0 indicates margin of t should be based on whether the margin\n\nof n + max_padding is greater than the current margin of t. Otherwise the margin n will be added to t.\n\noverride_join_lines_based_on_source is only used when join_lines_based_on_source option is true. In which\n\nn is added to t as if join_lines_based_on_source was false.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.align_binaryopcalls!-Tuple{JuliaFormatter.FST,Array{Int64,1}}","page":"API Reference","title":"JuliaFormatter.align_binaryopcalls!","text":"align_binaryopcalls!(fst::FST, op_idxs::Vector{Int})\n\nAligns binary operator expressions.\n\nAdditionally handles the case where a keyword such as const is used prior to the binary op call.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.align_conditional!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.align_conditional!","text":"align_conditional!(fst::FST)\n\nAligns a conditional expression.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.align_matrix!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.align_matrix!","text":"Adjust whitespace in between matrix elements such that it's the same as the original source file.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.align_struct!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.align_struct!","text":"align_struct!(fst::FST)\n\nAligns struct fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.annotate_typefields_with_any!-Tuple{JuliaFormatter.FST,JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.annotate_typefields_with_any!","text":"annotate_typefields_with_any!(fst::FST, s::State)\n\nAnnotates fields in a type definitions with ::Any if no type annotation is provided.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.binaryop_to_whereop!-Tuple{JuliaFormatter.FST,JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.binaryop_to_whereop!","text":"binaryop_to_whereop(fst::FST, s::State)\n\nHandles the case of a function def defined as:\n\nfoo(a::A)::R where A = body\n\nIn this case instead of it being parsed as (1):\n\nBinary\n - Where\n - OP\n - RHS\n\nIt's parsed as (2):\n\nBinary\n - Binary\n  - LHS\n  - OP\n  - Where\n   - R\n   - ...\n - OP\n - RHS\n\n(1) is preferrable since it's the same parsed result as:\n\nfoo(a::A) where A = body\n\nThis transformation converts (2) to (1).\n\nref https://github.com/julia-vscode/CSTParser.jl/issues/93\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.eq_to_in_normalization!-Tuple{JuliaFormatter.FST,Bool}","page":"API Reference","title":"JuliaFormatter.eq_to_in_normalization!","text":"eq_to_in_normalization!(fst::FST, always_for_in::Bool)\n\nTransforms\n\nfor i = iter body end\n\n=>\n\nfor i in iter body end\n\nAND\n\nfor i in 1:10 body end\n\n=>\n\nfor i = 1:10 body end\n\nhttps://github.com/domluna/JuliaFormatter.jl/issues/34\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.flatten_binaryopcall-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.flatten_binaryopcall","text":"Flattens a binary operation call tree if the operation repeats 2 or more times. \"a && b && c\" will be transformed while \"a && b\" will not.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format-Tuple{Any,JuliaFormatter.AbstractStyle}","page":"API Reference","title":"JuliaFormatter.format","text":"format(path, style::AbstractStyle; options...)::Bool\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format-Tuple{Any}","page":"API Reference","title":"JuliaFormatter.format","text":"format(\n    paths; # a path or collection of paths\n    options...,\n)::Bool\n\nRecursively descend into files and directories, formatting any .jl files by calling format_file on them.\n\nSee format_file and format_text for a description of the options.\n\nThis function will look for .JuliaFormatter.toml in the location of the file being formatted, and searching up the file tree until a config file is (or isn't) found. When found, the configurations in the file will overwrite the given options. See Configuration File for more details.\n\nOutput\n\nReturns a boolean indicating whether the file was already formatted (true) or not (false).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format-Tuple{Module,Vararg{Any,N} where N}","page":"API Reference","title":"JuliaFormatter.format","text":"format(mod::Module, args...; options...)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format_file-Tuple{AbstractString,JuliaFormatter.AbstractStyle}","page":"API Reference","title":"JuliaFormatter.format_file","text":"format_file(filename::AbstractString, style::AbstractStyle; kwargs...)::Bool\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format_file-Tuple{AbstractString}","page":"API Reference","title":"JuliaFormatter.format_file","text":"format_file(\n    filename::AbstractString;\n    overwrite::Bool = true,\n    verbose::Bool = false,\n    format_markdown::Bool = false,\n    format_options...,\n)::Bool\n\nFormats the contents of filename assuming it's a .jl or .md file.\n\nFile Options\n\noverwrite\n\ndefault: true\n\nIf true the file will be reformatted in place, overwriting the existing file; if it is false, the formatted version of foo.jl will not be written anywhere.\n\nverbose\n\ndefault: false\n\nIf true details related to formatting the file will be printed to stdout.\n\nformat_markdown\n\ndefault: false\n\nIf true, Markdown files are also formatted. Julia code blocks will be formatted in addition to the Markdown being normalized.\n\nFormatting Options\n\nSee format_text for description of formatting options.\n\nOutput\n\nReturns a boolean indicating whether the file was already formatted (true) or not (false).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format_md-Tuple{AbstractString}","page":"API Reference","title":"JuliaFormatter.format_md","text":"format_md(text::AbstractString; style::AbstractStyle = DefaultStyle(), kwargs...)\n\nNormalizes the Markdown source and formats Julia code blocks.\n\nSee format_text for description of formatting options.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.format_text-Tuple{AbstractString}","page":"API Reference","title":"JuliaFormatter.format_text","text":"format_text(\n    text::AbstractString;\n    style::AbstractStyle = DefaultStyle(),\n    indent::Int = 4,\n    margin::Int = 92,\n    always_for_in::Bool = false,\n    whitespace_typedefs::Bool = false,\n    whitespace_ops_in_indices::Bool = false,\n    remove_extra_newlines::Bool = false,\n    import_to_using::Bool = false,\n    pipe_to_function_call::Bool = false,\n    short_to_long_function_def::Bool = false,\n    always_use_return::Bool = false,\n    whitespace_in_kwargs::Bool = true,\n    annotate_untyped_fields_with_any::Bool = true,\n    format_docstrings::Bool = false,\n    align_struct_field::Bool = false,\n    align_conditional::Bool = false,\n    align_assignment::Bool = false,\n    align_pair_arrow::Bool = false,\n    conditional_to_if = false,\n    normalize_line_endings = \"auto\",\n    align_matrix::Bool = false,\n    trailing_comma::Bool = false,\n)::String\n\nFormats a Julia source passed in as a string, returning the formatted code as another string.\n\nFormatting Options\n\nindent\n\ndefault: 4\n\nThe number of spaces used for an indentation.\n\nmargin\n\ndefault: 92\n\nThe maximum length of a line. Code exceeding this margin will be formatted across multiple lines.\n\nalways_for_in\n\ndefault: false\n\nIf true, = is always replaced with in if part of a for loop condition. For example, for i = 1:10 will be transformed to for i in 1:10.\n\nwhitespace_typedefs\n\ndefault: false\n\nIf true, whitespace is added for type definitions. Make this true if you prefer Union{A <: B, C} to Union{A<:B,C}.\n\nwhitespace_ops_in_indices\n\ndefault: false\n\nIf true, whitespace is added for binary operations in indices. Make this true if you prefer arr[a + b] to arr[a+b]. Additionally, if there's a colon : involved, parenthesis will be added to the LHS and RHS.\n\nExample: arr[(i1 + i2):(i3 + i4)] instead of arr[i1+i2:i3+i4].\n\nremove_extra_newlines\n\ndefault: false\n\nIf true, superflous newlines will be removed. For example:\n\nmodule M\n\n\n\na = 1\n\nfunction foo()\n\n\n    return nothing\n\nend\n\n\nb = 2\n\n\nend\n\nis rewritten as\n\nmodule M\n\na = 1\n\nfunction foo()\n    return nothing\nend\n\nb = 2\n\nend\n\nModules are the only type of code block allowed to keep a single newline prior to the intial or after the final piece of code.\n\nimport_to_using\n\ndefault: false\n\nIf true, import expressions are rewritten to using expressions in the following cases:\n\nimport A\n\nimport A, B, C\n\nis rewritten to:\n\nusing A: A\n\nusing A: A\nusing B: B\nusing C: C\n\nExceptions:\n\nIf as is found in the import expression. using CANNOT be used in this context. The following example will NOT BE rewritten.\n\nimport Base.Threads as th\n\nIf import is used in the following context it is NOT rewritten. This may change in a future patch.\n\n@everywhere import A, B\n\npipe_to_function_call\n\ndefault: false\n\nIf true, x |> f is rewritten to f(x).\n\nshort_to_long_function_def\n\ndefault: false\n\nTransforms a short function definition\n\nf(arg1, arg2) = body\n\nto a long function definition\n\nfunction f(arg2, arg2)\n    body\nend\n\nalways_use_return\n\ndefault: false\n\nIf true, return will be prepended to the last expression where applicable in function definitions, macro definitions, and do blocks.\n\nExample:\n\nfunction foo()\n    expr1\n    expr2\nend\n\nto\n\nfunction foo()\n    expr1\n    return expr2\nend\n\nwhitespace_in_kwargs\n\ndefault: true\n\nIf true, = in keyword arguments will be surrounded by whitespace.\n\nf(; a=4)\n\nto\n\nf(; a = 4)\n\nAn exception to this is if the LHS ends with \"!\" then even if whitespace_in_kwargs is false, = will still be surrounded by whitespace. The logic behind this intervention being on the following parse the ! will be treated as part of =, as in a \"not equal\" binary operation. This would change the semantics of the code and is therefore disallowed.\n\nannotate_untyped_fields_with_any\n\ndefault: true\n\nAnnotates fields in a type definitions with ::Any if no type annotation is provided:\n\nstruct A\n    arg1\nend\n\nto\n\nstruct A\n    arg1::Any\nend\n\nformat_docstrings\n\ndefault: false\n\nFormat code docstrings with the same options used for the code source.\n\nMarkdown is formatted with CommonMark alongside Julia code.\n\nalign_*\n\ndefault: false\n\nSee Custom Alignment documentation.\n\nconditional_to_if\n\ndefault: false\n\nIf the conditional E ? A : B exceeds the maximum margin converts it into the equivalent if block:\n\nif E\n    A\nelse\n    B\nend\n\nnormalize_line_endings\n\ndefault: \"auto\"\n\nOne of \"unix\" (normalize all  to ), \"windows\" (normalize all  to ), \"auto\" (automatically choose based on which line ending is more common in the file).\n\ntrailing_comma\n\ndefault: true\n\nOne of true, false, or nothing.\n\nTrailing commas are added after the final argument when nesting occurs and the closing punctuation appears on the next line.\n\nFor example when the following is nested (assuming DefaultStyle):\n\nfunccall(arg1, arg2, arg3)\n\nit turns into:\n\nfunccall(\n    arg1,\n    arg2,\n    arg3, # trailing comma added after `arg3` (final arugment) !!!\n)\n\nWhen set to true, the trailing comma is always added during nesting.\nWhen set to false, the trailing comma is always removed during nesting.\nWhen set to nothing, the trailing comma appears as it does in the original source.\n\njoin_lines_based_on_source\n\ndefault: false\n\nWhen true lines are joined as they appear in the original source file.\n\nfunction foo(arg1,\n                       arg2, arg3\n                       )\n       body\nend\n\nWhen false and the maximum margin is > than the length of \"function foo(arg1, arg2, arg3)\" this is formatted to\n\nfunction foo(arg1, arg2, arg3)\n    body\nend\n\nWhen true, arg1 and arg2, arg3 will remain on separate lines even if they can fit on the same line since it's within maximum margin. The indentation is dependent on the style.\n\nfunction foo(arg1,\n    arg2, arg3,\n)\nend\n\nThere are exceptions to this:\n\nif a body1 elseif b body2 else body3 end\n\nwill be formatted to the following, even if this option is set to true:\n\nif a\n    body1\nelseif b\n    body2\nelse\n    body3\nend\n\nwarning: Warning\nThe maximum margin still applies even when this option is set to true.\n\nindent_inner_module\n\ndefault: false\n\nWhen set to true inner modules will be indented.\n\nmodule A\na = 1\n\nmodule B\nb = 2\nmodule C\nc = 3\nend\nend\n\nd = 4\n\nend\n\nwill be formatted to:\n\nmodule A\na = 1\n\nmodule B\n    b = 2\n    module C\n        c = 3\n    end\nend\n\nd = 4\n\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.is_iterable_arg-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.is_iterable_arg","text":"Returns whether fst can be an iterable argument. For example in the case of a function call, which is of type Call:\n\n(a, b, c; k1=v1)\n\nThis would return true for a, b, c and k1=v1 and false for all other nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.is_standalone_shortcircuit-Tuple{CSTParser.EXPR}","page":"API Reference","title":"JuliaFormatter.is_standalone_shortcircuit","text":"is_standalone_shortcircuit(cst::CSTParser.EXPR)\n\nReturns true if the cst is a short-circuit expression (uses &&, ||) and is standalone, meaning it's not directly associated with another statement or expression.\n\nExamples\n\n# this IS a standalone short-circuit\na && b\n\n# this IS NOT a standalone short-circuit\nif a && b\nend\n\n# this IS NOT a standalone short-circuit\nvar = a && b\n\n# this IS NOT a standalone short-circuit\n@macro a && b\n\n# operation inside parenthesis IS NOT a standalone short-circuit\n# operation outside parenthesis IS a standalone short-circuit\n(a && b) && c\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.length_to-Tuple{JuliaFormatter.FST,Any}","page":"API Reference","title":"JuliaFormatter.length_to","text":"`length_to(x::FST, ntyps; start::Int = 1)`\n\nReturns the length to any node type in ntyps based off the start index.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.move_at_sign_to_the_end-Tuple{JuliaFormatter.FST,JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.move_at_sign_to_the_end","text":"move_at_sign_to_the_end(fst::FST, s::State)\n\nNOTE: Assumes fst is the caller name of a macrocall such as @macro or Module.@macro.\n\nMoves @ to the last indentifier.\n\nExample:\n\n@Module.macro\n\nto\n\nModule.@macro\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.nest_if_over_margin!-Tuple{Any,JuliaFormatter.FST,JuliaFormatter.State,Int64}","page":"API Reference","title":"JuliaFormatter.nest_if_over_margin!","text":"nest_if_over_margin!(\n    style,\n    fst::FST,\n    s::State,\n    idx::Int;\n    stop_idx::Union{Int,Nothing} = nothing,\n)::Bool\n\nConverts the node at idx to a NEWLINE if the current margin plus the additional margin from fst[idx:stop_idx-1] is greater than the allowed margin.\n\nIf stop_idx == nothing the range is fst[idx:end].\n\nReturns whether nesting occurred.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.p_macrostr_identifier-Tuple{DefaultStyle,CSTParser.EXPR,JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.p_macrostr_identifier","text":"This is a special prettifier to handle the case of string macros. As such it is not part of pretty.\n\nformat\"hello\"\n\nThe above \"format\" identifier is parsed by CSTParser as if the text is \"@format_str\". This creates problems when we format without intervention:\n\n\"@format_str\" is printed instead of \"format\"\nThe state offset is incorrect since the length of \"@format_str\" is greater than \"format\"\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.pipe_to_function_call_pass!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.pipe_to_function_call_pass!","text":"pipe_to_function_call_pass!(fst::FST)\n\nRewrites x |> f to f(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.prepend_return!-Tuple{JuliaFormatter.FST,JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.prepend_return!","text":"prepend_return!(fst::FST, s::State)\n\nPrepends return to the last expression of a block if applicable.\n\nfunction foo()\n    a = 2 * 3\n    a / 3\nend\n\nto\n\nfunction foo()\n    a = 2 * 3\n    return a / 3\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.remove_superflous_whitespace!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.remove_superflous_whitespace!","text":"remove_superflous_whitespace!(fst::FST)\n\nSoft deletes WHITESPACE or PLACEHOLDER that's directly followed by a NEWLINE or INLINECOMMENT node.\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.separate_kwargs_with_semicolon!-Tuple{JuliaFormatter.FST}","page":"API Reference","title":"JuliaFormatter.separate_kwargs_with_semicolon!","text":"separate_kwargs_with_semicolon!(fst::FST)\n\nEnsures keyword arguments are separated by a \";\".\n\nExamples\n\nReplace \",\" with \";\".\n\na = f(x, y = 3)\n\n->\n\na = f(x; y = 3)\n\nMove \";\" to the prior to the first positional argument.\n\na = f(x = 1; y = 2)\n\n->\n\na = f(; x = 1, y = 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.short_to_long_function_def!-Tuple{JuliaFormatter.FST,JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.short_to_long_function_def!","text":"short_to_long_function_def!(fst::FST, s::State)\n\nTransforms a short function definition\n\nf(arg1, arg2) = body\n\nto a long function definition\n\nfunction f(arg2, arg2)\n    body\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.unnestable_node-Tuple{CSTParser.EXPR}","page":"API Reference","title":"JuliaFormatter.unnestable_node","text":"cst is assumed to be a single child node. Returns true if the node is of the syntactic form {...}, [...], or (...).\n\n\n\n\n\n","category":"method"},{"location":"api/#JuliaFormatter.walk-Tuple{Any,JuliaFormatter.FST,JuliaFormatter.State}","page":"API Reference","title":"JuliaFormatter.walk","text":"walk(f, fst::FST, s::State)\n\nWalks fst calling f on each node.\n\nIn situations where descending further into a subtree is not desirable f should return a value other than nothing.\n\n\n\n\n\n","category":"method"},{"location":"transforms/#Syntax-Tree-Transformations","page":"Syntax Transforms","title":"Syntax Tree Transformations","text":"","category":"section"},{"location":"transforms/#for-in-vs.-for","page":"Syntax Transforms","title":"for in vs. for =","text":"","category":"section"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"By default if the RHS is a range, i.e. 1:10 then for in is converted to for =. Otherwise for = is converted to for in. See this issue for the rationale and further explanation.","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"Alternative to the above - setting always_for_in to true, i.e. format_text(..., always_for_in = true) will always convert = to in even if the RHS is a range.","category":"page"},{"location":"transforms/#Trailing-Commas","page":"Syntax Transforms","title":"Trailing Commas","text":"","category":"section"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"If the node is iterable, for example a function call or list and is nested, a trailing comma is added to the last argument. The trailing comma is removed if unnested:","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"func(a, b, c)\n\n->\n\nfunc(\n    a,\n    b,\n    c,\n)","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"See this issue for more details.","category":"page"},{"location":"transforms/#Trailing-Semicolons","page":"Syntax Transforms","title":"Trailing Semicolons","text":"","category":"section"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"If a matrix node is nested the semicolons are removed.","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"A = [1 0; 0 1]\n\n->\n\nA = [\n    1 0\n    0 1\n]","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"See this issue for more details.","category":"page"},{"location":"transforms/#Leading-and-trailing-0s-for-float-literals","page":"Syntax Transforms","title":"Leading and trailing 0s for float literals","text":"","category":"section"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"If a float literal is missing a trailing 0 it is added:","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"a = 1.\n\n->\n\na = 1.0","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"If a float literal is missing a leading 0 it is added:","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"a = .1\n\n->\n\na = 0.1","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"For Float32 if there is no decimal point, .0 is added:","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"a = 1f0\n\n->\n\na = 1.0f0","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"See this issue for more details.","category":"page"},{"location":"transforms/#Surround-where-arguments-with-curly-brackets","page":"Syntax Transforms","title":"Surround where arguments with curly brackets","text":"","category":"section"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"If the arguments of a where call are not surrounded by curly brackets, they are added:","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"foo(x::T) where T = ...\n\n->\n\nfoo(x::T) where {T} = ...","category":"page"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"See this issue for more details.","category":"page"},{"location":"transforms/#Annotate-unannotated-type-fields-with-Any","page":"Syntax Transforms","title":"Annotate unannotated type fields with Any","text":"","category":"section"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"struct Foo\n    field\nend\n\n->\n\nstruct Foo\n    field::Any\nend","category":"page"},{"location":"transforms/#Move-@-in-macro-calls-to-the-final-identifier","page":"Syntax Transforms","title":"Move @ in macro calls to the final identifier","text":"","category":"section"},{"location":"transforms/","page":"Syntax Transforms","title":"Syntax Transforms","text":"@Module.macro\n\n->\n\nModule.@macro","category":"page"},{"location":"custom_alignment/#Custom-Alignment","page":"Custom Alignment","title":"Custom Alignment","text":"","category":"section"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Solution for issue 179","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Custom alignment is determined by a whitespace heuristic:","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"A token (typically an operator, i.e. =, ?, ::, etc) is custom aligned if there are > 1 whitespaces from the previous expression since the formatter only outputs 0 or 1 whitespaces for separation. If custom alignment is determined then all expressions in the code block will be aligned to the furthest aligned token.","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"NOTE: alignment overrides nesting behavior, meaning it ignores the allowed maximum margin","category":"page"},{"location":"custom_alignment/#Example","page":"Custom Alignment","title":"Example","text":"","category":"section"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Suppose the source text is as follows","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"const variable1 = 1\nconst var2      = 2\nconst var3 = 3\nconst var4 = 4\nconst var5          = 5","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"If the align_assignment option is enabled the formatter will detect that var2 is aligned to variable1 AND var2 has several whitespaces (>1) prior to =. Since var3,var4, and var5 are part of the same code block (no comments or newlines separating code) they will also be aligned.","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"So the output would be","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"const variable1 = 1\nconst var2      = 2\nconst var3      = 3\nconst var4      = 4\nconst var5      = 5","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Notice how the = operator for var5 is correctly positioned despite it being located further to the right than other = operators.","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"However, if the source code is","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"const variable1 = 1\nconst variable2 = 2\nconst var3 = 3\nconst var4 = 4\nconst var5 = 5","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"It's now ambiguous whether this is meant to be aligned and so the formatter will proceed with normal behavior.","category":"page"},{"location":"custom_alignment/#Alignment-Options","page":"Custom Alignment","title":"Alignment Options","text":"","category":"section"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"In order for alignment to occur the option must be set to true. Available options:","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"align_assignment\nalign_struct_field\nalign_conditional\nalign_pair_arrow\nalign_matrix","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Caveat: Since nesting is disabled when alignment occurs be careful when adding comments to the RHS expression. This will be fixed in a future release","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"For example:","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"const variable1 = 1\nconst var2      = foo(10,\n    # comment,\n    20)","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"This will be formatted to","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"const variable1 = 1\nconst var2      = foo(10, # comment, 20)","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"which causes a parsing error.","category":"page"},{"location":"custom_alignment/#align_assignment","page":"Custom Alignment","title":"align_assignment","text":"","category":"section"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Align to =-like operators. This covers variable assignments and short definition functions.","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"const UTF8PROC_STABLE    = (1 << 1)\nconst UTF8PROC_COMPAT    = (1 << 2)\nconst UTF8PROC_COMPOSE   = (1 << 3)\nconst UTF8PROC_DECOMPOSE = (1 << 4)\nconst UTF8PROC_IGNORE    = (1 << 5)\nconst UTF8PROC_REJECTNA  = (1 << 6)\nconst UTF8PROC_NLF2LS    = (1 << 7)\nconst UTF8PROC_NLF2PS    = (1 << 8)\nconst UTF8PROC_NLF2LF    = (UTF8PROC_NLF2LS | UTF8PROC_NLF2PS)\nconst UTF8PROC_STRIPCC   = (1 << 9)\nconst UTF8PROC_CASEFOLD  = (1 << 10)\nconst UTF8PROC_CHARBOUND = (1 << 11)\nconst UTF8PROC_LUMP      = (1 << 12)\nconst UTF8PROC_STRIP     = (1 << 13)\n\n\nvcat(X::T...) where {T}         = T[X[i] for i = 1:length(X)]\nvcat(X::T...) where {T<:Number} = T[X[i] for i = 1:length(X)]\nhcat(X::T...) where {T}         = T[X[j] for i = 1:1, j = 1:length(X)]\nhcat(X::T...) where {T<:Number} = T[X[j] for i = 1:1, j = 1:length(X)]\n\na  = 1\nbc = 2\n\nlong_variable = 1\nother_var     = 2","category":"page"},{"location":"custom_alignment/#align_struct_field","page":"Custom Alignment","title":"align_struct_field","text":"","category":"section"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Align struct field definitions to :: or = - whichever has higher precedence.","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Base.@kwdef struct Options\n    indent::Int                            = 4\n    margin::Int                            = 92\n    always_for_in::Bool                    = false\n    whitespace_typedefs::Bool              = false\n    whitespace_ops_in_indices::Bool        = false\n    remove_extra_newlines::Bool            = false\n    import_to_using::Bool                  = false\n    pipe_to_function_call::Bool            = false\n    short_to_long_function_def::Bool       = false\n    always_use_return::Bool                = false\n    whitespace_in_kwargs::Bool             = true\n    annotate_untyped_fields_with_any::Bool = true\n    format_docstrings::Bool                = false\n    align_struct_fields::Bool              = false\n\n    # no custom whitespace so this block is not aligned\n    another_field1::BlahBlahBlah = 10\n    field2::Foo = 10\n\n    # no custom whitespace but single line blocks are not aligned\n    # either way\n    Options() = new()\nend\n\n\nmutable struct Foo\n    a             :: T\n    longfieldname :: T\nend","category":"page"},{"location":"custom_alignment/#align_conditional","page":"Custom Alignment","title":"align_conditional","text":"","category":"section"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Align conditional expressions to either ?, :, or both.","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"# This will remain like this if using YASStyle\nindex = zeros(n <= typemax(Int8)  ? Int8  :\n              n <= typemax(Int16) ? Int16 :\n              n <= typemax(Int32) ? Int32 : Int64, n)\n\n# Using DefaultStyle\nindex = zeros(\n    n <= typemax(Int8)  ? Int8  :\n    n <= typemax(Int16) ? Int16 :\n    n <= typemax(Int32) ? Int32 : Int64,\n    n,\n)\n\n# Note even if the maximum margin is set to 1, the alignment remains intact\nindex =\n    zeros(\n        n <= typemax(Int8)  ? Int8  :\n        n <= typemax(Int16) ? Int16 :\n        n <= typemax(Int32) ? Int32 : Int64,\n        n,\n    )\n","category":"page"},{"location":"custom_alignment/#align_pair_arrow","page":"Custom Alignment","title":"align_pair_arrow","text":"","category":"section"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Align pair arrows (=>).","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"pages = [\n    \"Introduction\"        => \"index.md\",\n    \"How It Works\"        => \"how_it_works.md\",\n    \"Code Style\"          => \"style.md\",\n    \"Skipping Formatting\" => \"skipping_formatting.md\",\n    \"Syntax Transforms\"   => \"transforms.md\",\n    \"Custom Alignment\"    => \"custom_alignment.md\",\n    \"Custom Styles\"       => \"custom_styles.md\",\n    \"YAS Style\"           => \"yas_style.md\",\n    \"Configuration File\"  => \"config.md\",\n    \"API Reference\"       => \"api.md\",\n]","category":"page"},{"location":"custom_alignment/#align_matrix","page":"Custom Alignment","title":"align_matrix","text":"","category":"section"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"TLDR: If you want to align matrix elements yourself set this to true","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"Whitespace surrounding matrix elements in the original source file is maintained. Differs from other alignment options since it does not try to \"detect\" alignment and then adjust other elements.","category":"page"},{"location":"custom_alignment/","page":"Custom Alignment","title":"Custom Alignment","text":"# Elements left-aligned in original source\njulia> s = \"\"\"\n       a = [\n       100 300 400\n       1   eee 40000\n       2   α   b\n       ]\"\"\"\n\"a = [\\n100 300 400\\n1   eee 40000\\n2   α   b\\n]\"\n\njulia> format_text(s, align_matrix=true) |> print\na = [\n    100 300 400\n    1   eee 40000\n    2   α   b\n]\n\n# Elements right-aligned in original source\njulia> s = \"\"\"\n       a = [\n       100 300   400\n         1  ee 40000\n         2   a     b\n       ]\"\"\"\n\"a = [\\n100 300   400\\n  1  ee 40000\\n  2   a     b\\n]\"\n\njulia>\n\njulia> format_text(s, align_matrix=true) |> print\na = [\n    100 300   400\n      1  ee 40000\n      2   a     b\n]","category":"page"},{"location":"custom_styles/#Custom-Styles","page":"Custom Styles","title":"Custom Styles","text":"","category":"section"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"The default style surrounds keyword arguments with whitespace. Suppose we wanted to have no spaces, how could we do this? Using custom styles this turns out to be easy.","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"First we'll define the style:","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"using JuliaFormatter, CSTParser\nusing JuliaFormatter: AbstractStyle, FST, State, add_node!\nimport JuliaFormatter: pretty, p_kw\n\nstruct CustomStyle <: AbstractStyle end\n\n# this must be defined\ngetstyle(s::CustomStyle) = s","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"Next we'll create a function for the p_kw to dispatch on CustomStyle.","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"function p_kw(style::CustomStyle, cst::CSTParser.EXPR, s::State)\n    t = FST(cst, 0)\n    for a in cst\n        add_node!(t, pretty(style, a, s), s, join_lines = true)\n    end\n    t\nend","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"For comparison here's the default definition:","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"function p_kw(style::DefaultStyle, cst::CSTParser.EXPR, s::State)\n    style = getstyle(style)\n    t = FST(cst, nspaces(s))\n    for a in cst\n        if a.kind === Tokens.EQ\n            add_node!(t, Whitespace(1), s)\n            add_node!(t, pretty(style, a, s), s, join_lines = true)\n            add_node!(t, Whitespace(1), s)\n        else\n            add_node!(t, pretty(style, a, s), s, join_lines = true)\n        end\n    end\n    t\nend","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"And that's it! All other functions will fallback to use DefaultStyle.","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"Finally, let's check the output:","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"julia> s = \"foo(a,b, key1=val1, key3=val4)\"\n\"foo(a,b, key1=val1, key3=val4)\"\n\njulia> format_text(s) |> print\nfoo(a, b, key1 = val1, key3 = val4)\n\njulia> format_text(s, style=CustomStyle()) |> print\nfoo(a, b, key1=val1, key3=val4)","category":"page"},{"location":"custom_styles/","page":"Custom Styles","title":"Custom Styles","text":"Nice! Looks like it's working.","category":"page"},{"location":"how_it_works/#How-It-Works","page":"How It Works","title":"How It Works","text":"","category":"section"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"The formatter takes a .jl file as input and produce a idealized, formatted .jl as output. Some formatters mutate the state of the current file, JuliaFormatter takes a different approach - first generating a canonical output, and then mutating that canonical output; adhering to the indent and margin constraints.","category":"page"},{"location":"how_it_works/#Generating-an-FST","page":"How It Works","title":"Generating an FST","text":"","category":"section"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"The source code is parsed with CSTParser.jl which returns a CST (Concrete Syntax Tree). A CST is a one-to-one mapping of the language to a tree form. In most cases a more compact AST (Abstract Syntax Tree) representation is desired. However, since formatting manipulate the source text itself, the richer representation of a CST is incredibly useful.","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"Once the CST is created it's then used to generate a FST (Formatted Syntax Tree).","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"Note: this is not an actual term, just something I made up. Essentially it's a CST with additional formatting specific metadata.","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"The important part of an FST is any .jl file that is syntactically the same (whitespace is irrelevant) produce an identical FST.","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"For example:","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"# p1.jl\na = \n       foo(a,                     b,           \n       c,d)","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"and","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"# p2.jl\na =                      foo(a,\nb,\nc,d)","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"will produce the same FST, which printed would look like:","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"# fst output\na = foo(a, b, c, d)","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"So what does a typical FST look like?","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"Code and comments are indented to match surrounding code blocks. Uncessary whitespace is removed. Newlines in between code blocks are untouched.","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"If the expression can be put on a single line it will be. It doesn't matter it's a function call which 120 arguments, making it 1000 characters long. During this initial stage it will be put on a single line.","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"If the expression has a structure to it, such as a try, if, or 'struct' definition. It will be spread across multiple lines appropriately:","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"\n# original source\ntry a1;a2 catch e b1;b2 finally c1;c2 end\n\n-> \n\n# printed FST\ntry\n   a1\n   a2\ncatch e\n   b1\n   b2\nfinally\n   c1\n   c2\nend","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"With this FST representation it's much easier to determine when and how lines should be broken.","category":"page"},{"location":"how_it_works/#Nesting-breaking-lines","page":"How It Works","title":"Nesting - breaking lines","text":"","category":"section"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"During the nesting stage and original FST is mutated to adhere to the margin specification.","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"Throughout the previous stage, while the FST was being generated, PLACEHOLDER nodes were being inserted at various points. These can be converted to NEWLINE nodes during nesting, which is how lines are broken.","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"Assume we had a function call which went over the margin.","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"begin\n    foo = funccall(argument1, argument2, ..., argument120) # way over margin limit !!!\nend","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"It would be nested to","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"begin\n    foo = funccall(\n        argument1,\n        argument2,\n        ...,\n        argument120\n    ) # way over margin limit !!!\nend","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"You can read how code is nested in the style section.","category":"page"},{"location":"how_it_works/","page":"How It Works","title":"How It Works","text":"Once the FST has been nested it's then printed out to a file and voila! You have a formatted version of your code!","category":"page"},{"location":"skipping_formatting/#Skipping-Formatting","page":"Skipping Formatting","title":"Skipping Formatting","text":"","category":"section"},{"location":"skipping_formatting/","page":"Skipping Formatting","title":"Skipping Formatting","text":"By default formatting is always on but can be toggled with the following comments:","category":"page"},{"location":"skipping_formatting/","page":"Skipping Formatting","title":"Skipping Formatting","text":"#! format: off\n# Turns off formatting from this point onwards\n...\n\n#! format: on\n# Turns formatting back on from this point onwards","category":"page"},{"location":"skipping_formatting/","page":"Skipping Formatting","title":"Skipping Formatting","text":"These can be used throughout a file, or, for an entire file not be formatted add \"format: off\" at the top of the file:","category":"page"},{"location":"skipping_formatting/","page":"Skipping Formatting","title":"Skipping Formatting","text":"#! format: off\n#\n# It doesn't actually matter if it's on\n# the first line of the line but anything\n# onwards will NOT be formatted.\n\nmodule Foo\n...\nend","category":"page"},{"location":"skipping_formatting/","page":"Skipping Formatting","title":"Skipping Formatting","text":"Note the formatter expects #! format: on and #! format: off to be on its own line and the whitespace to be an exact match.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = JuliaFormatter","category":"page"},{"location":"#JuliaFormatter.jl","page":"Introduction","title":"JuliaFormatter.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Build Status)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Width-sensitive formatter for Julia code. Inspired by gofmt, refmt, black, and prettier. Built with CSTParser.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Sane defaults out of the box with options to customize.\nSupports YAS and Blue style guides.\n.JuliaFormatter.toml configuration file to store options.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"]add JuliaFormatter","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using JuliaFormatter\n\n# Recursively formats all Julia files in the current directory\njulia> format(\".\")\n\n# Formats an individual file\njulia> format_file(\"foo.jl\")\n\n# Formats a string (contents of a Julia file)\njulia> format_text(str)\n\n# Formats all files in the package directory of a `Module`\njulia> format(FooPackage)","category":"page"},{"location":"#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaFormatter exports format, format_file, format_text, and format_md.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"format_md has the same API as format_text but differ in that format_md expects the text content to be a Markdown document.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See format_text docstring for formatting options at the text level and format_file docstring for formatting options at the file level.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"JuliaFormatter should work on any valid Julia and Markdown files.  If JuliaFormatter cannot parse the code for any reason, it will throw an error pointing to the line that could not be parsed. If running format on multiple files, you may want to set verbose = true to print information about which file is being formatted.","category":"page"}]
}
